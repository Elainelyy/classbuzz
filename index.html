<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ClassBuzz Polls</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Use CropperJS instead of ReactCrop -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.js"></script>
    
    <!-- PDF.js for PDF rendering -->
    <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@2.11.338/build/pdf.min.js"></script>
    <script>
      if (window.pdfjsLib) {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@2.11.338/build/pdf.worker.min.js';
      }
    </script>
    
    <!-- Import our styles -->
    <link rel="stylesheet" href="/styles/main.css">
    
    <!-- Import our API clients -->
    <script type="module" src="/scripts/api/pollApi.js"></script>
    <script type="module" src="/scripts/api/questionApi.js"></script>
</head>
<body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <script type="text/babel">
      const { useState, useEffect, useMemo, useCallback, useRef } = React;

      // Import API clients
      import pollApi from '/scripts/api/pollApi.js';
      import questionApi from '/scripts/api/questionApi.js';

      // --- Utility Functions ---
      function classNames(...classes) { return classes.filter(Boolean).join(' '); }

      // --- Components ---
      function Comment({ comment }) {
        return (
          <div className="ml-4 mt-2 p-2 bg-gray-100 rounded text-sm text-gray-700">
            <p>{comment.text}</p>
          </div>
        );
      }

      function Question({ question, onVote, onAddComment, onToggleAnswer, isSpeaker }) {
        const [showComments, setShowComments] = useState(false);
        const [newComment, setNewComment] = useState('');
        const [commentError, setCommentError] = useState(null);

        const comments = question.comments || [];

        const handleAddCommentSubmit = async (e) => {
          e.preventDefault();
          const trimmedComment = newComment.trim();
          if (!trimmedComment) return;

          setCommentError(null); // Clear previous errors
          try {
            // Call the async function passed down from RaiseHandTool
            await onAddComment(question.id, trimmedComment);
            setNewComment(''); // Clear input on success
            setShowComments(true); // Keep comments open
          } catch (error) {
            console.error("Failed to add comment:", error);
            setCommentError(error.message || "Failed to post comment. Please try again.");
          }
        };

        return (
          <div className={classNames( "border rounded-lg p-4 mb-4 shadow-sm transition-colors duration-200", question.is_answered ? 'bg-green-50 border-green-200' : 'bg-white border-gray-200 hover:bg-gray-50' )}>
            <div className="flex items-start justify-between gap-4">
              <div className="flex-grow min-w-0">
                <p className={classNames( "text-gray-800 break-words", question.is_answered ? 'line-through text-gray-500' : '' )}>
                  {question.text}
                </p>
                <div className="text-sm text-gray-500 mt-2 flex flex-wrap items-center gap-x-4 gap-y-1">
                  {/* Vote Button */}
                  <button onClick={() => onVote(question.id)} disabled={question.is_answered} className={classNames( "flex items-center px-2 py-1 rounded transition-colors duration-150", question.is_answered ? "text-gray-400 cursor-not-allowed" : "text-blue-600 hover:bg-blue-100 disabled:opacity-50" )} aria-label={`Vote for question: ${question.text}`} >
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V7z" clipRule="evenodd" /></svg>
                    <span>{question.votes} Vote{question.votes !== 1 ? 's' : ''}</span>
                  </button>
                  {/* Comment Toggle Button */}
                  <button onClick={() => setShowComments(!showComments)} className="flex items-center text-gray-600 hover:text-indigo-600 text-sm" aria-expanded={showComments} aria-controls={`comments-${question.id}`} >
                     <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" /></svg>
                     {comments.length} Comment{comments.length !== 1 ? 's' : ''}
                  </button>
                   {/* Answered Status Badge */}
                   {question.is_answered && (
                      <span className="text-green-600 font-medium text-xs inline-flex items-center bg-green-100 px-2 py-0.5 rounded-full">
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-3 w-3 mr-1" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" /></svg>
                        Answered
                      </span>
                    )}
                </div>
              </div>
              {/* Speaker Action Button */}
              {isSpeaker && ( <button onClick={() => onToggleAnswer(question.id, !question.is_answered)} className={classNames( "flex-shrink-0 text-sm font-medium px-3 py-1 rounded transition-colors duration-150 self-start", question.is_answered ? 'bg-yellow-100 text-yellow-700 hover:bg-yellow-200' : 'bg-green-100 text-green-700 hover:bg-green-200' )} > {question.is_answered ? 'Mark Unanswered' : 'Mark Answered'} </button> )}
            </div>

            {/* Comments Section */}
            {showComments && (
              <div id={`comments-${question.id}`} className="mt-3 pl-4 border-l-2 border-gray-200">
                {comments.length > 0 ? (
                  comments.map(comment => <Comment key={comment.id} comment={comment} />)
                ) : ( <p className="text-sm text-gray-500 italic">No comments yet.</p> )}
                <form onSubmit={handleAddCommentSubmit} className="mt-3 flex items-center">
                  <input type="text" value={newComment} onChange={(e) => setNewComment(e.target.value)} placeholder="Add a comment..." className="flex-grow border border-gray-300 rounded-l px-3 py-1.5 text-sm focus:outline-none focus:ring-1 focus:ring-indigo-500 focus:border-indigo-500" aria-label="Add a comment to this question" />
                  <button type="submit" className="bg-indigo-600 text-white px-3 py-1.5 rounded-r text-sm font-medium hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-indigo-500 transition-colors duration-150 disabled:opacity-50" disabled={!newComment.trim()} > Add </button>
                </form>
                {commentError && <p className="error-inline">{commentError}</p>}
              </div>
            )}
          </div>
        );
      }

      /**
       * The main view for the "Raise Hand" tool.
       */
      function RaiseHandTool({ onGoBack }) {
        const [questions, setQuestions] = useState([]);
        const [isLoading, setIsLoading] = useState(true);
        const [error, setError] = useState(null);
        const [newQuestion, setNewQuestion] = useState('');
        const [isSpeaker, setIsSpeaker] = useState(false);

        const fetchQuestions = useCallback(async () => {
          setIsLoading(true);
          setError(null);
          try {
            const data = await questionApi.getAllQuestions();
            // Converts created_at string from the database into a Date object, which is easier to work with in the UI.
            const questionsWithDates = data.map(q => ({
                ...q,
                createdAt: new Date(q.created_at),
                comments: (q.comments || []).map(c => ({ ...c, createdAt: new Date(c.created_at) }))
            }));
            setQuestions(questionsWithDates);
          } catch (e) {
            console.error("Failed to fetch questions:", e);
            setError("Failed to load questions. Please try again later.");
          } finally {
            setIsLoading(false);
          }
        }, []);

        useEffect(() => {
          fetchQuestions();
        }, [fetchQuestions]);

        // --- Add Question ---
        const handleAddQuestion = async (e) => {
          e.preventDefault();
          const trimmedQuestion = newQuestion.trim();
          if (!trimmedQuestion) return;
          setNewQuestion('');

          try {
            const addedQuestion = await questionApi.createQuestion({ text: trimmedQuestion });
            const newQ = {
                ...addedQuestion,
                createdAt: new Date(addedQuestion.created_at),
                comments: (addedQuestion.comments || []).map(c => ({ ...c, createdAt: new Date(c.created_at) }))
            };
            setQuestions(prevQuestions => [newQ, ...prevQuestions]);
          } catch (e) {
            console.error("Failed to add question:", e);
            setError(`Failed to add question: ${e.message}. Please try again.`);
            setNewQuestion(trimmedQuestion);
          }
        };

        // --- Vote ---
        const handleVote = useCallback(async (questionId) => {
          const originalQuestions = questions;
          setQuestions(prevQuestions =>
            prevQuestions.map(q =>
              q.id === questionId ? { ...q, votes: q.votes + 1 } : q
            )
          );

          try {
            await questionApi.voteQuestion(questionId);
          } catch (e) {
            console.error("Failed to vote:", e);
            setError(`Vote failed: ${e.message}`);
            setQuestions(originalQuestions);
          }
        }, [questions]); // Include questions to get latest state for revert

        // --- Add Comment ---
        const handleAddComment = useCallback(async (questionId, commentText) => {
          try {
            const newComment = await questionApi.addComment(questionId, { text: commentText });
            setQuestions(prevQuestions =>
              prevQuestions.map(q =>
                q.id === questionId
                  ? {
                      ...q,
                      comments: [
                          ...(q.comments || []),
                          { ...newComment, createdAt: new Date(newComment.created_at) }
                      ].sort((a, b) => new Date(a.created_at) - new Date(b.created_at))
                    }
                  : q
              )
            );
          } catch (e) {
            throw new Error(e.message || "Failed to add comment");
          }
        }, []);

        // --- Toggle Answer ---
        const handleToggleAnswer = useCallback(async (questionId, newAnsweredState) => {
          if (!isSpeaker) return;
          const originalQuestions = questions;

          setQuestions(prevQuestions =>
            prevQuestions.map(q =>
              q.id === questionId ? { ...q, is_answered: newAnsweredState } : q
            )
          );

          try {
            await questionApi.markQuestionAnswered(questionId);
          } catch (e) {
            console.error("Failed to toggle answer status:", e);
            setError(`Update failed: ${e.message}`);
            setQuestions(originalQuestions);
          }
        }, [isSpeaker, questions]); // Include questions for revert, isSpeaker for check

        const sortedQuestions = useMemo(() => {
          return [...questions].sort((a, b) => {
            if (a.is_answered !== b.is_answered) { return a.is_answered ? 1 : -1; }
            if (b.votes !== a.votes) { return b.votes - a.votes; }
            const dateA = a.createdAt instanceof Date ? a.createdAt.getTime() : 0;
            const dateB = b.createdAt instanceof Date ? b.createdAt.getTime() : 0;
            return dateA - dateB;
          });
        }, [questions]);

        // --- Render UI ---
        return (
          <div className="p-4 sm:p-6 bg-gray-50 min-h-screen font-sans relative">
             <button onClick={onGoBack} className="absolute top-4 left-4 z-10 bg-white text-indigo-600 px-3 py-1 rounded-md shadow text-sm font-medium hover:bg-indigo-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" aria-label="Go back to tool list" > &larr; Back to Tools </button>
             <div className="max-w-3xl mx-auto bg-white p-6 rounded-lg shadow-md mt-12 sm:mt-16">
                {/* Header and Speaker Toggle */}
                <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-6 pb-4 border-b border-gray-200 gap-4">
                  <h2 className="text-2xl font-semibold text-gray-800 flex-shrink-0">Raise Hand / Q&A</h2>
                  <label className="flex items-center cursor-pointer flex-shrink-0">
                    <span className="mr-2 text-sm font-medium text-gray-700">Speaker Mode:</span>
                    <div className="relative">
                      <input type="checkbox" className="sr-only peer" checked={isSpeaker} onChange={() => setIsSpeaker(!isSpeaker)} id="speaker-toggle" />
                      <div className="w-10 h-6 rounded-full transition bg-gray-300 peer-checked:bg-indigo-600"></div>
                      <div className="absolute left-1 top-1 bg-white w-4 h-4 rounded-full transition transform peer-checked:translate-x-4 dot"></div>
                    </div>
                  </label>
                </div>
                {/* Add Question Form */}
                <form onSubmit={handleAddQuestion} className="mb-6 flex flex-col sm:flex-row gap-2">
                  <input type="text" value={newQuestion} onChange={(e) => setNewQuestion(e.target.value)} placeholder="Ask a question..." className="flex-grow border border-gray-300 rounded-md px-4 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500" aria-label="Ask a new question" />
                  <button type="submit" className="bg-indigo-600 text-white px-4 py-2 rounded-md font-medium hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-colors duration-150 disabled:opacity-50" disabled={!newQuestion.trim()} > Ask </button>
                </form>
                 {/* Display Top-Level Error */}
                 {error && <div className="message-box error mb-4">{error}</div>}

                {/* Display Loading / Questions List */}
                <div className="space-y-4">
                   <h3 className="text-lg font-medium text-gray-700 mb-2">Questions</h3>
                   {isLoading && <div className="message-box loading">Loading questions...</div>}
                   {!isLoading && !error && sortedQuestions.length === 0 && (
                       <p className="text-gray-500 italic text-center py-4">No questions asked yet. Be the first!</p>
                   )}
                   {!isLoading && !error && sortedQuestions.length > 0 && (
                      sortedQuestions.map(question => (
                        <Question
                          key={question.id}
                          question={question}
                          onVote={handleVote}
                          onAddComment={handleAddComment}
                          onToggleAnswer={handleToggleAnswer}
                          isSpeaker={isSpeaker}
                        />
                      ))
                   )}
                </div>
             </div>
          </div>
        );
      }

      // ## Poll Tool Components ##

      function PollResults({ results, totalVotes, options }) {
        if (totalVotes === 0) { return <p className="text-sm text-gray-500 italic mt-4">No votes yet.</p>; }
        return ( <div className="mt-6 space-y-3"> <h4 className="font-medium text-gray-700">Results ({totalVotes} total votes):</h4> {options.map(option => { const count = results[option] || 0; const percentage = totalVotes > 0 ? ((count / totalVotes) * 100).toFixed(1) : 0; return ( <div key={option} className="result-bar-bg"> <span className="result-label">{option}</span> <div className="result-bar" style={{ width: `${percentage}%` }}> <span className="result-percentage">{percentage}%</span>&nbsp;({count}) </div> </div> ); })} </div> );
      }

      function PollEditor({ poll, onSave, onCancel }) {
        // --- State Management ---
        const [question, setQuestion] = useState(poll ? poll.question : '');
        const [options, setOptions] = useState(poll ? poll.options : ['', '']);
        const [pollType, setPollType] = useState(poll ? poll.poll_type : 'single_choice');
        
        // Image/PDF state
        const [image, setImage] = useState(null);
        const [imagePreview, setImagePreview] = useState(poll && poll.image_url ? poll.image_url : null);
        const [isCropping, setIsCropping] = useState(false);
        const [fileType, setFileType] = useState(null);
        const [completedCrop, setCompletedCrop] = useState(null);
        const [pdfDoc, setPdfDoc] = useState(null);
        const [currentPage, setCurrentPage] = useState(1);
        const [totalPages, setTotalPages] = useState(0);
        const [isRenderingPdf, setIsRenderingPdf] = useState(false);
        
        // UI state
        const [isLoading, setIsLoading] = useState(false);
        const [error, setError] = useState(null);
        
        // --- Refs ---
        const fileInputRef = useRef(null);
        const cropperImageRef = useRef(null);
        const cropperInstanceRef = useRef(null);
        
        // --- Effects ---
        // Initialize with poll data if editing
        useEffect(() => {
          if (poll) {
            setQuestion(poll.question || '');
            setOptions(poll.options?.length ? poll.options : ['', '']);
            setPollType(poll.poll_type || 'single_choice');
            setImagePreview(poll.image_url || null);
            
            // Clean up if poll changes
            handleRemoveImage(); // Ensure image state is reset
          }
        }, [poll]);

        // Function to initialize CropperJS
        const initializeCropper = () => {
          // Destroy previous instance if it exists
          if (cropperInstanceRef.current) {
            cropperInstanceRef.current.destroy();
            cropperInstanceRef.current = null;
          }
          
          // Make sure the image element is available
          if (!cropperImageRef.current) return;
          
          // Give time for the image to load
          setTimeout(() => {
            try {
              cropperInstanceRef.current = new Cropper(cropperImageRef.current, {
                viewMode: 1,
                dragMode: 'crop',
                autoCrop: false,
                zoomable: true,
                scalable: false,
                movable: true,
                background: false,
                ready() {
                  console.log("Cropper is ready");
                  if (cropperImageRef.current) {
                    cropperImageRef.current.classList.add('loaded');
                  }
                },
                crop(event) {
                  // Enable apply crop button when a valid crop area is selected
                  const data = event.detail;
                  if (data.width > 0 && data.height > 0) {
                    setCompletedCrop(true);
                  } else {
                    setCompletedCrop(null);
                  }
                }
              });
            } catch (err) {
              console.error("Error initializing cropper:", err);
              setError("Could not initialize image cropper. Please try again.");
            }
          }, 100);
        };

        // PDF Page Rendering
        const renderPdfPage = async (pdfDocument, pageNum) => {
          if (!pdfDocument || isRenderingPdf) return;
          setIsRenderingPdf(true);
          setError(null); // Clear previous errors

          try {
            const page = await pdfDocument.getPage(pageNum);
            const viewport = page.getViewport({ scale: 1.5 });
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;

            const renderContext = {
              canvasContext: context,
              viewport: viewport,
            };
            await page.render(renderContext).promise;

            const pageDataUrl = canvas.toDataURL('image/png');
            setImage(pageDataUrl);
            setImagePreview(null);
            setCurrentPage(pageNum);
            setIsCropping(true);
            setFileType('image/png');
            
            // Reset crop state when page changes
            setCompletedCrop(null);
            
            // Initialize cropper on next render
            setTimeout(() => {
              if (cropperImageRef.current) {
                cropperImageRef.current.src = pageDataUrl;
                cropperImageRef.current.style.display = 'block';
                initializeCropper();
              }
            }, 100);

          } catch (pdfError) {
            console.error('Error rendering PDF page:', pdfError);
            setError(`Failed to render PDF page ${pageNum}. Please try another file.`);
            handleRemoveImage();
          } finally {
            setIsRenderingPdf(false);
          }
        };

        const handlePrevPage = () => {
          if (currentPage > 1) {
            renderPdfPage(pdfDoc, currentPage - 1);
          }
        };

        const handleNextPage = () => {
          if (currentPage < totalPages) {
            renderPdfPage(pdfDoc, currentPage + 1);
          }
        };

        // Image/Upload Handling
        const handleImageUpload = async (e) => {
          const file = e.target.files[0];
          if (!file) return;

          // Clean up previous state
          handleRemoveImage();
          setFileType(file.type);

          if (file.type === 'application/pdf') {
            if (!window.pdfjsLib) {
              setError("PDF library not available.");
              return;
            }
            const reader = new FileReader();
            reader.onload = async (event) => {
              try {
                const loadingTask = window.pdfjsLib.getDocument({ data: event.target.result });
                const pdf = await loadingTask.promise;
                setPdfDoc(pdf);
                setTotalPages(pdf.numPages);
                renderPdfPage(pdf, 1); // Render the first page immediately
              } catch (pdfError) {
                console.error('Error loading PDF:', pdfError);
                setError('Failed to load PDF. The file might be corrupted or invalid.');
                handleRemoveImage();
              }
            };
            reader.onerror = () => {
               setError('Failed to read the PDF file.');
               handleRemoveImage();
            }
            reader.readAsArrayBuffer(file);
          } else if (file.type.startsWith('image/')) {
            // Handle image files
            setPdfDoc(null);
            setTotalPages(0);
            setCurrentPage(1);
            
            const reader = new FileReader();
            reader.onload = (e) => {
              // Get the data URL
              const imageDataUrl = e.target.result;
              
              // Set the image and enter cropping mode
              setImage(imageDataUrl);
              setImagePreview(null);
              setIsCropping(true);
              
              // Initialize cropper on next render
              setTimeout(() => {
                if (cropperImageRef.current) {
                  cropperImageRef.current.src = imageDataUrl;
                  cropperImageRef.current.style.display = 'block';
                  initializeCropper();
                }
              }, 100);
            };
            reader.onerror = () => {
              setError('Failed to read the image file.');
              handleRemoveImage();
            };
            reader.readAsDataURL(file);
          } else {
            alert('Please upload an image (JPEG, PNG, GIF) or PDF file');
            handleRemoveImage();
          }
        };

        const handleRemoveImage = () => {
          // Revoke existing object URLs if they exist
          if (image && image.startsWith('blob:')) {
            URL.revokeObjectURL(image);
          }
          if (imagePreview && imagePreview.startsWith('blob:')) {
            URL.revokeObjectURL(imagePreview);
          }

          // Destroy cropper instance if it exists
          if (cropperInstanceRef.current) {
            cropperInstanceRef.current.destroy();
            cropperInstanceRef.current = null;
          }

          // Reset state
          setImage(null);
          setImagePreview(null);
          setFileType(null);
          setIsCropping(false);
          setPdfDoc(null);
          setCurrentPage(1);
          setTotalPages(0);
          setCompletedCrop(null);
          
          // Reset the file input
          if (fileInputRef.current) {
            fileInputRef.current.value = '';
          }
          
          // Hide the cropper image
          if (cropperImageRef.current) {
            cropperImageRef.current.src = '';
            cropperImageRef.current.style.display = 'none';
            cropperImageRef.current.classList.remove('loaded');
          }
        };

        const handleCropComplete = () => {
          if (!cropperInstanceRef.current) {
            setError("Cropper not initialized.");
            return;
          }
          
          try {
            // Get cropped canvas from CropperJS with reasonable settings
            const croppedCanvas = cropperInstanceRef.current.getCroppedCanvas({
              imageSmoothingEnabled: true,
              imageSmoothingQuality: 'high',
              maxWidth: 1000, // Reasonable size limit
              maxHeight: 1000,
              fillColor: '#fff'
            });
            
            if (!croppedCanvas) {
              setError("Could not get cropped image. Please try again.");
              return;
            }
            
            // Convert to medium quality JPEG data URL (0.8 quality)
            const croppedImageDataUrl = croppedCanvas.toDataURL('image/jpeg', 0.8);
            
            console.log("Generated cropped image:", 
                      "Size:", Math.round(croppedImageDataUrl.length/1024), "KB",
                      "Format:", croppedImageDataUrl.substring(0, 30) + "...");
            
            // Set the data URL as the image preview
            setImagePreview(croppedImageDataUrl);
            setImage(null);
            setIsCropping(false);
            setCompletedCrop(true);
            
            // Cleanup
            if (cropperInstanceRef.current) {
              cropperInstanceRef.current.destroy();
              cropperInstanceRef.current = null;
            }
            
            // Clear PDF data
            setPdfDoc(null);
            setTotalPages(0);
            setCurrentPage(1);
            
            // Clear the file input
            if (fileInputRef.current) {
              fileInputRef.current.value = '';
            }
          } catch (e) {
            console.error("Error creating cropped image:", e);
            setError("Failed to generate cropped image. Please try again.");
          }
        };

        // --- Form Handling ---
        const handleAddOption = () => {
          setOptions([...options, '']);
        };

        const handleRemoveOption = (index) => {
          if (options.length > 2) {
            setOptions(options.filter((_, i) => i !== index));
          }
        };

        const handleOptionChange = (index, value) => {
          const newOptions = [...options];
          newOptions[index] = value;
          setOptions(newOptions);
        };

        const handleSubmit = async (e) => {
          e.preventDefault();
          setIsLoading(true);
          setError(null);

          // Basic validation
          if (!question.trim() && !imagePreview && !image) {
             setError('Please provide a question or upload an image/PDF.');
             setIsLoading(false);
             return;
          }
          
          if (pollType !== 'open_ended') {
            const validOptions = options.filter(opt => opt.trim() !== '');
            if (validOptions.length < 2) {
              setError('Multiple choice/Single choice polls require at least two non-empty options.');
              setIsLoading(false);
              return;
            }
            if (new Set(validOptions).size !== validOptions.length) {
              setError('Duplicate options are not allowed.');
              setIsLoading(false);
              return;
            }
          }

          // If currently cropping and image exists but no imagePreview, use the original image
          if (isCropping && image && !imagePreview) {
            // Use original image automatically
            await handleUseOriginalImage();
          }

          // Verify image data
          if (imagePreview) {
            console.log("Image data format check:", 
                       "Starts with data:image?", imagePreview.startsWith('data:image/'),
                       "Contains base64?", imagePreview.includes(';base64,'));
          }
          
          // Format poll data for submission
          const pollData = {
            id: poll ? poll.id : null,
            question: question.trim(),
            options: pollType === 'open_ended' ? [] : options.map(opt => opt.trim()).filter(opt => opt !== ''),
            pollType: pollType
          };
          
          // Include image data if available, with compression to avoid 413 Payload Too Large errors
          if (imagePreview && imagePreview.startsWith('data:')) {
            // Compress the image before sending if it's large
            try {
              const compressedImage = await compressImage(imagePreview);
              pollData.imageDataUrl = compressedImage;
              console.log("Including compressed image data in request");
            } catch (err) {
              console.error("Error compressing image:", err);
              setError("Failed to compress image. The file may be too large.");
              setIsLoading(false);
              return;
            }
          } else if (poll && poll.image_url) {
            // If editing and no new image, keep the existing one
            pollData.existingImageUrl = poll.image_url;
            console.log("Using existing image URL:", poll.image_url);
          } else if (imagePreview) {
            // If it's neither a data URL nor existing poll URL, it might be a direct URL
            pollData.existingImageUrl = imagePreview;
            console.log("Using direct image URL:", imagePreview);
          }

          console.log("Sending poll data with question:", pollData.question, 
                     "Has image data:", !!pollData.imageDataUrl);

          try {
            // Make the API call to save the poll
            await onSave(pollData);
            
            // Reset form after successful save only if creating new
            if (!poll) {
               setQuestion('');
               setOptions(['', '']);
               setPollType('single_choice');
               handleRemoveImage();
            }
          } catch (saveError) {
            console.error("Error saving poll:", saveError);
            setError(saveError.message || 'Failed to save poll');
          } finally {
            setIsLoading(false);
          }
        };

        // Add an image compression function to reduce file size
        const compressImage = (dataUrl) => {
          return new Promise((resolve, reject) => {
            try {
              const img = new Image();
              img.onload = () => {
                // Create a canvas to draw the compressed image
                const canvas = document.createElement('canvas');
                
                // Calculate dimensions (max 1000px width/height while maintaining aspect ratio)
                let width = img.width;
                let height = img.height;
                const maxDimension = 1000;
                
                if (width > maxDimension || height > maxDimension) {
                  if (width > height) {
                    height = Math.round((height * maxDimension) / width);
                    width = maxDimension;
                  } else {
                    width = Math.round((width * maxDimension) / height);
                    height = maxDimension;
                  }
                }
                
                canvas.width = width;
                canvas.height = height;
                
                // Draw the image on the canvas with the new dimensions
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);
                
                // Calculate quality based on input size ratio. Add a small buffer to ensure we don't overshoot
                const targetSize = 200 * 1024; // 200KB in bytes
                const inputSize = dataUrl.length;
                let quality = Math.min(0.9, Math.max(0.1, (targetSize / inputSize).toFixed(1)));
                
                console.log("Compression calculation:", {
                  "Input size": Math.round(inputSize/1024) + "KB",
                  "Target size": "200KB",
                  "Calculated quality": quality
                });
                
                // Generate compressed image
                const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                
                console.log("Final compression result:", {
                  "Original size": Math.round(inputSize/1024) + "KB",
                  "Compressed size": Math.round(compressedDataUrl.length/1024) + "KB",
                  "Reduction": Math.round((1 - compressedDataUrl.length/inputSize) * 100) + "%",
                  "Quality used": quality,
                  "Final dimensions": `${width}x${height}`
                });
                
                resolve(compressedDataUrl);
              };
              
              img.onerror = () => {
                reject(new Error("Failed to load image for compression"));
              };
              
              img.src = dataUrl;
            } catch (err) {
              reject(err);
            }
          });
        };

        // Make handleUseOriginalImage return a promise to support await in handleSubmit
        const handleUseOriginalImage = () => {
          return new Promise((resolve) => {
            if (!image) {
              setError("No image available.");
              resolve(false);
              return;
            }
            
            // Set the original image as the preview
            setImagePreview(image);
            setIsCropping(false);
            setCompletedCrop(true);
            
            // Cleanup cropper
            if (cropperInstanceRef.current) {
              cropperInstanceRef.current.destroy();
              cropperInstanceRef.current = null;
            }
            
            resolve(true);
          });
        };

        // --- Render ---
        return (
          <div className="poll-editor">
            <h2>{poll ? 'Edit Poll' : 'Create New Poll'}</h2>
            {error && <p className="error-message">{error}</p>}
            <form onSubmit={handleSubmit}>
              {/* Question Input */}
              <div className="form-group">
                <label>Question:</label>
                <input
                  type="text"
                  value={question}
                  onChange={(e) => setQuestion(e.target.value)}
                  placeholder="Enter your poll question (optional if image/PDF provided)"
                />
              </div>

              {/* Image/PDF Upload and Crop Area */}
              <div className="form-group">
                  <label>Image or PDF (optional if question provided):</label>
                  <div
                      className={`image-upload-container ${isCropping ? 'cropping' : ''}`}
                      onDragOver={(e) => { e.preventDefault(); e.currentTarget.classList.add('drag-over'); }}
                      onDragLeave={(e) => { e.preventDefault(); e.currentTarget.classList.remove('drag-over'); }}
                      onDrop={(e) => {
                          e.preventDefault();
                          e.currentTarget.classList.remove('drag-over');
                          const file = e.dataTransfer.files[0];
                          if (file) {
                              // Simulate event object for handleImageUpload
                              handleImageUpload({ target: { files: [file] } });
                          }
                      }}
                  >
                      {/* Display Area: Shows final preview, cropper, or upload prompt */}
                      {!isCropping && imagePreview ? (
                          // 1. Final Preview (after cropping or if editing existing)
                          <div className="image-preview-container">
                              <img src={imagePreview} alt="Preview" className="image-preview" />
                          </div>
                      ) : isCropping && image ? (
                          // 2. Cropping Interface (Image or Rendered PDF Page)
                          <div className="image-crop-container">
                               {pdfDoc && totalPages > 0 && (
                                   <div className="pdf-navigation">
                                      <button type="button" onClick={handlePrevPage} disabled={currentPage <= 1 || isRenderingPdf}>Previous</button>
                                      <span>Page {currentPage} of {totalPages}</span>
                                      <button type="button" onClick={handleNextPage} disabled={currentPage >= totalPages || isRenderingPdf}>Next</button>
                                  </div>
                               )}
                               
                               {/* CropperJS Image Element */}
                               <img 
                                 ref={cropperImageRef} 
                                 id="cropperImage" 
                                 src={image} 
                                 alt="Crop Source" 
                                 style={{ display: isRenderingPdf ? 'none' : 'block' }} 
                               />
                               
                               {isRenderingPdf && <p>Loading PDF page...</p>}
                               <div className="crop-controls">
                                   <button
                                       type="button"
                                       onClick={handleCropComplete}
                                       className="crop-button"
                                       disabled={!completedCrop || isRenderingPdf}
                                   >
                                       Apply Crop
                                   </button>
                                   <button 
                                       type="button" 
                                       onClick={handleUseOriginalImage} 
                                       className="use-original-button"
                                       disabled={isRenderingPdf}
                                   >
                                       Use Original
                                   </button>
                                   <button type="button" onClick={handleRemoveImage} className="cancel-crop-button">Cancel</button>
                               </div>
                          </div>
                      ) : (
                          // 3. Upload Prompt
                          <div className="upload-area" onClick={() => fileInputRef.current?.click()}>
                              <div className="upload-icon">üìÅ</div>
                              <p>Drag and drop an image or PDF here</p>
                              <p>or</p>
                              <button type="button" className="upload-button">
                                  Browse Files
                              </button>
                          </div>
                      )}

                      {/* Hidden File Input */}
                      <input
                          type="file"
                          ref={fileInputRef}
                          accept="image/jpeg,image/png,image/gif,application/pdf"
                          onChange={handleImageUpload}
                          style={{ display: 'none' }}
                      />

                      {/* Remove Button (shows if there's a preview or source image) */}
                      {(imagePreview || image) && !isCropping && (
                           <button
                                type="button"
                                onClick={handleRemoveImage}
                                className="remove-image"
                                style={{ marginTop: '10px' }} // Adjust spacing as needed
                            >
                                Remove Image
                            </button>
                      )}
                  </div>
              </div>


              {/* Poll Type Selection */}
              <div className="form-group">
                <label>Poll Type:</label>
                <select value={pollType} onChange={(e) => setPollType(e.target.value)}>
                  <option value="single_choice">Single Choice</option>
                  <option value="multiple_choice">Multiple Choice</option>
                  <option value="open_ended">Open Ended</option>
                </select>
              </div>

              {/* Options (Conditional) */}
              {pollType !== 'open_ended' && (
                <div className="form-group">
                  <label>Options:</label>
                  {options.map((option, index) => (
                    <div key={index} className="option-input">
                      <input
                        type="text"
                        value={option}
                        onChange={(e) => handleOptionChange(index, e.target.value)}
                        placeholder={`Option ${index + 1}`}
                        required
                      />
                      {options.length > 2 && (
                        <button type="button" onClick={() => handleRemoveOption(index)} className="remove-option">
                          Remove
                        </button>
                      )}
                    </div>
                  ))}
                  <button type="button" onClick={handleAddOption} className="add-option">
                    Add Option
                  </button>
                </div>
              )}

              {/* Form Actions */}
              <div className="form-actions">
                <button type="button" onClick={onCancel} className="cancel-button" disabled={isLoading}>
                  Cancel
                </button>
                <button type="submit" className="save-button" disabled={isLoading}>
                  {isLoading ? 'Saving...' : (poll ? 'Update Poll' : 'Create Poll')}
                </button>
              </div>
            </form>
          </div>
        );
      }


      /**
       * The main view for the "Poll" tool - Updated Speaker View & Audience Navigation.
       */
      function PollTool({ onGoBack }) {
          const [polls, setPolls] = useState([]);
          const [isSpeaker, setIsSpeaker] = useState(false);
          const [submittedAnswers, setSubmittedAnswers] = useState({});
          const [editingPollId, setEditingPollId] = useState(null);
          const [isLoading, setIsLoading] = useState(true);
          const [error, setError] = useState(null);
          const [selectedOption, setSelectedOption] = useState(null);
          const [pollResults, setPollResults] = useState({});

          // For audience navigation
          const [currentAudiencePollIndex, setCurrentAudiencePollIndex] = useState(0);

          // Filter polls for audience view (Active or Ended only)
          const visibleAudiencePolls = useMemo(() => 
            polls.filter(p => p.poll_status === 'active' || p.poll_status === 'ended'), 
            [polls]
          );

          // Get the specific poll the audience is currently viewing
          const currentAudiencePoll = visibleAudiencePolls[currentAudiencePollIndex];

          // Check submission status for current poll
          const hasSubmittedCurrentPoll = currentAudiencePoll ? submittedAnswers[currentAudiencePoll.id] : false;

          // Reset audience selection when viewed poll changes
           useEffect(() => {
            // Ensure index is valid when the list of visible polls changes
              const newIndex = Math.min(currentAudiencePollIndex, Math.max(0, visibleAudiencePolls.length - 1));
            if (newIndex !== currentAudiencePollIndex && visibleAudiencePolls.length > 0) {
                // Only update index if it's actually out of bounds AND there are visible polls
                  setCurrentAudiencePollIndex(newIndex);
            } else if (visibleAudiencePolls.length === 0 && currentAudiencePollIndex !== 0) {
                // Reset index if the list becomes empty
                setCurrentAudiencePollIndex(0);
            }
            
            // Reset selection for the new poll
            setSelectedOption(null);
          }, [currentAudiencePollIndex, visibleAudiencePolls]);

          // Fetch polls from the API
          const fetchPolls = useCallback(async () => {
            setIsLoading(true);
            setError(null);
            try {
              const data = await pollApi.getAllPolls();
              setPolls(data);
            } catch (e) {
              console.error("Failed to fetch polls:", e);
              setError("Failed to load polls. Please try again later.");
            } finally {
              setIsLoading(false);
            }
          }, []);

          useEffect(() => {
            fetchPolls();
          }, [fetchPolls]);

          // Fetch poll results when needed
          useEffect(() => {
            if (currentAudiencePoll && currentAudiencePoll.poll_status === 'ended' && !pollResults[currentAudiencePoll.id]) {
              fetchPollResults(currentAudiencePoll.id);
            }
          }, [currentAudiencePoll]);
          
          // Function to fetch poll results
          const fetchPollResults = async (pollId) => {
            try {
              const data = await pollApi.getPollResults(pollId);
              setPollResults(prev => ({
                ...prev,
                [pollId]: data
              }));
            } catch (e) {
              console.error(`Failed to fetch results for poll ${pollId}:`, e);
            }
          };

          // Function to handle edit poll button click
          const handleEditPoll = (poll) => {
            setEditingPollId(poll.id);
          };

          // Handle creating or updating a poll
          const handleSavePoll = async (pollData) => {
            try {
              setIsLoading(true);
              setError(null); // Clear previous errors

              const isEditing = !!pollData.id;

              // Validate options array
              if (pollData.pollType !== 'open_ended') {
                if (!pollData.options || !Array.isArray(pollData.options)) {
                  throw new Error('Options must be an array for non-open-ended polls');
                }
                const validOptions = pollData.options.filter(opt => opt.trim() !== '');
                if (validOptions.length < 2) {
                  throw new Error('At least two non-empty options are required');
                }
                if (new Set(validOptions).size !== validOptions.length) {
                  throw new Error('Duplicate options are not allowed');
                }
              } else {
                // For open-ended polls, ensure options is an empty array
                pollData.options = pollData.options || [];
              }

              // Validate that either question or image is provided
              if (!pollData.question && !pollData.imageDataUrl && !pollData.existingImageUrl) {
                throw new Error('Either question or image must be provided');
              }

              // Prepare request body
              const requestBody = {
                question: pollData.question || "",
                options: pollData.options || [],
                poll_type: pollData.pollType
              };
              
              // Include the full base64 data URL if available, otherwise include the existing image URL
              if (pollData.imageDataUrl) {
                requestBody.imageDataUrl = pollData.imageDataUrl;
              } else if (pollData.existingImageUrl) {
                requestBody.existingImageUrl = pollData.existingImageUrl;
              }

              let responseData;
              if (isEditing) {
                responseData = await pollApi.updatePoll(pollData.id, requestBody);
              } else {
                responseData = await pollApi.createPoll(requestBody);
              }

              // Success: Refetch polls to update the list
              await fetchPolls();
              setEditingPollId(null); // Close the editor

            } catch (e) {
              console.error('Error saving poll:', e);
              setError(e.message || 'An unexpected error occurred while saving.');
            } finally {
              setIsLoading(false);
            }
          };

          // Handle updating poll status
          const handleTogglePollStatus = async (pollId) => {
            try {
              const currentPoll = polls.find(p => p.id === pollId);
              if (!currentPoll) return;

              const nextStatusMap = {
                idle: 'active',
                active: 'ended',
                ended: 'idle' // Defaulting back to idle
              };
              const newStatus = nextStatusMap[currentPoll.poll_status] || 'idle';
              const updatedPoll = await pollApi.updatePollStatus(pollId, newStatus);
              setPolls(prevPolls => prevPolls.map(p => p.id === pollId ? updatedPoll : p));
            } catch (e) {
              console.error("Failed to update poll status:", e);
              setError("Failed to update poll status. Please try again.");
            }
          };

          // Handle selecting an option
          const handleSelectOption = (option) => {
            if (hasSubmittedCurrentPoll || !currentAudiencePoll || currentAudiencePoll.poll_status !== 'active') return;
            setSelectedOption(option);
          };

          // Handle submitting a vote
             
          const handleSubmitVote = async (pollId) => {
            if (!selectedOption && currentAudiencePoll?.poll_type !== 'open_ended') {
              alert("Please select an option first");
              return;
            }
            
            try {
              const optionIndex = currentAudiencePoll.options.indexOf(selectedOption);
              const tempUserId = 1; 
              
              if (optionIndex === -1 && currentAudiencePoll?.poll_type !== 'open_ended') {
                throw new Error("Selected option not found in poll options");
              }
              
              await pollApi.submitVote(pollId, tempUserId, optionIndex);
              setSubmittedAnswers(prev => ({ ...prev, [pollId]: true }));
              fetchPolls();
            } catch (e) {
              console.error("Failed to submit vote:", e);
              setError("Failed to submit vote: " + (e.message || "Please try again."));
            }
          };

          // Handle submitting an open answer
          // TODO: Replace with real user authentication 
          const handleSubmitOpenAnswer = async (pollId, answerText) => {
            if (!answerText) {
              alert("Please enter an answer");
              return;
            }
            
            try {
              const tempUserId = 1; // TODO: Replace with real user authentication
              await pollApi.submitOpenAnswer(pollId, tempUserId, answerText);
              setSubmittedAnswers(prev => ({ ...prev, [pollId]: true }));
              setSelectedOption(null);
              fetchPolls();
            } catch (e) {
              console.error("Failed to submit answer:", e);
              setError("Failed to submit answer: " + (e.message || "Please try again."));
            }
          };

          // Handle deleting a poll
          const handleDeletePoll = async (pollId) => {
            if (!confirm("Are you sure you want to delete this poll? This action cannot be undone.")) {
              return;
            }
            
            try {
              await pollApi.deletePoll(pollId);
              setPolls(prevPolls => prevPolls.filter(p => p.id !== pollId));
            } catch (e) {
              console.error("Failed to delete poll:", e);
              setError("Failed to delete poll: " + (e.message || "Please try again."));
            }
          };

          // Audience Navigation Handlers
          const handleAudienceNextPoll = () => {
              if (currentAudiencePollIndex < visibleAudiencePolls.length - 1) {
                setCurrentAudiencePollIndex(prev => prev + 1);
              }
          };
          
          const handleAudiencePrevPoll = () => {
              if (currentAudiencePollIndex > 0) {
                setCurrentAudiencePollIndex(prev => prev - 1);
            }
          };

          // --- Render Logic ---
          return (
              <div className="p-4 sm:p-6 bg-gray-50 min-h-screen font-sans relative">
                  <button onClick={onGoBack} className="absolute top-4 left-4 z-10 bg-white text-indigo-600 px-3 py-1 rounded-md shadow text-sm font-medium hover:bg-indigo-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" aria-label="Go back to tool list">
                      &larr; Back to Tools
                  </button>

                  <div className="max-w-3xl mx-auto bg-white p-6 rounded-lg shadow-md mt-12 sm:mt-16">
                      {/* Header & Speaker Toggle */}
                      <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-6 pb-4 border-b border-gray-200 gap-4">
                          <h2 className="text-2xl font-semibold text-gray-800 flex-shrink-0">Poll Tool</h2>
                          <label className="flex items-center cursor-pointer flex-shrink-0">
                              <span className="mr-2 text-sm font-medium text-gray-700">Speaker Mode:</span>
                              <div className="relative">
                                  <input type="checkbox" className="sr-only peer" checked={isSpeaker} onChange={() => { 
                                      setIsSpeaker(!isSpeaker); 
                                      setEditingPollId(null);
                                      setCurrentAudiencePollIndex(0); // Reset index when switching modes
                                  }} id="poll-speaker-toggle" />
                                  <div className="w-10 h-6 rounded-full transition bg-gray-300 peer-checked:bg-indigo-600"></div>
                                  <div className="absolute left-1 top-1 bg-white w-4 h-4 rounded-full transition transform peer-checked:translate-x-4 dot"></div>
                              </div>
                          </label>
                      </div>

                      {/* Loading and Error States */}
                      {isLoading ? (
                        <div className="message-box loading">
                          <p>Loading polls...</p>
                        </div>
                      ) : error ? (
                        <div className="message-box error">
                          <p>{error}</p>
                          <button 
                            onClick={fetchPolls}
                            className="mt-2 bg-red-100 text-red-800 px-4 py-2 rounded"
                          >
                            Try Again
                          </button>
                        </div>
                      ) : (
                        /* Main Content */
                        isSpeaker ? (
                          // --- Speaker View ---
                          <div>
                              {editingPollId !== null ? (
                                  // Show Editor when creating or editing
                                    <PollEditor 
                                        key={editingPollId} 
                                        poll={editingPollId === 'new' ? null : polls.find(p => p.id === editingPollId)} 
                                        onSave={handleSavePoll} 
                                        onCancel={() => setEditingPollId(null)} 
                                    />
                              ) : (
                                  // Show Poll List and Create Button when not editing
                                  <div>
                                        <button onClick={() => setEditingPollId('new')} className="w-full mb-6 bg-indigo-600 text-white px-4 py-2 rounded-md font-medium hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-colors duration-150" > + Create New Poll </button>
                                      <h3 className="text-lg font-medium text-gray-700 mb-3">Manage Polls</h3>
                                      {polls.length === 0 ? ( <p className="text-center text-gray-500 py-4">No polls created yet.</p> ) : (
                                          <div className="space-y-3">
                                              {polls.map(poll => (
                                                  <div key={poll.id} className="poll-list-item">
                                                      <div className="flex-1 min-w-0 pr-4">
                                                          <p className="text-gray-800 font-medium truncate" title={poll.question}>{poll.question}</p>
                                                            <span className={classNames( 
                                                                'status-badge', 
                                                                poll.poll_status === 'idle' && 'status-idle', 
                                                                poll.poll_status === 'active' && 'status-active', 
                                                                poll.poll_status === 'ended' && 'status-ended'
                                                            )}>
                                                                {poll.poll_status || 'idle'}
                                                            </span>
                                                          {/* Optionally show results summary for speaker */}
                                                            {poll.poll_status !== 'idle' && <p className="text-xs text-gray-500 mt-1">{poll.total_votes || 0} vote(s)</p>}
                                                      </div>
                                                      <div className="flex gap-2 flex-shrink-0">
                                                            <button 
                                                                onClick={() => handleEditPoll(poll)} 
                                                                disabled={poll.poll_status === 'active'} 
                                                                className="text-sm bg-white border border-gray-300 text-gray-700 px-3 py-1 rounded-md hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
                                                            >
                                                                Edit
                                                            </button>
                                                            <button 
                                                                onClick={() => handleTogglePollStatus(poll.id)} 
                                                                className={classNames(
                                                                    "text-sm text-white px-3 py-1 rounded-md transition-colors",
                                                                    poll.poll_status === 'active' ? 'bg-red-500 hover:bg-red-600' : 'bg-green-500 hover:bg-green-600',
                                                                    poll.poll_status === 'ended' && 'bg-gray-400 hover:bg-gray-500'
                                                                )}
                                                            >
                                                                {poll.poll_status === 'active' ? 'End Poll' : poll.poll_status === 'ended' ? 'Resume' : 'Start Poll'}
                                                            </button>
                                                            <button 
                                                                onClick={() => handleDeletePoll(poll.id)}
                                                                className="text-sm bg-red-100 text-red-700 px-3 py-1 rounded-md hover:bg-red-200 transition-colors"
                                                            >
                                                                Delete
                                                            </button>
                                                      </div>
                                                  </div>
                                              ))}
                                          </div>
                                      )}
                                  </div>
                              )}
                          </div>
                      ) : (
                            // --- Audience View (Shows only active and ended polls, one at a time) ---
                            visibleAudiencePolls.length === 0 ? (
                                <p className="text-center text-gray-500 py-8">No polls are currently available to view.</p>
                          ) : (
                              <div>
                                    {/* Audience Poll Navigation */}
                                  <div className="flex justify-between items-center mb-4">
                                      <button
                                          onClick={handleAudiencePrevPoll}
                                          disabled={currentAudiencePollIndex === 0}
                                          className="text-indigo-600 hover:text-indigo-800 disabled:opacity-50 disabled:cursor-not-allowed"
                                      >
                                          &larr; Previous
                                      </button>
                                        <span className="text-sm text-gray-500">
                                            Poll {currentAudiencePollIndex + 1} of {visibleAudiencePolls.length}
                                        </span>
                                      <button
                                          onClick={handleAudienceNextPoll}
                                          disabled={currentAudiencePollIndex === visibleAudiencePolls.length - 1}
                                          className="text-indigo-600 hover:text-indigo-800 disabled:opacity-50 disabled:cursor-not-allowed"
                                      >
                                          Next &rarr;
                                      </button>
                                  </div>

                                    {/* Display Current Audience Poll */}
                                    {currentAudiencePoll && (
                                      <>
                                          <h3 className="text-xl font-semibold text-gray-800 mb-5 text-center">{currentAudiencePoll.question}</h3>

                                            {/* Display poll image if exists */}
                                            {currentAudiencePoll.image_url && (
                                                <div className="mb-6 flex justify-center">
                                                    <img 
                                                        src={currentAudiencePoll.image_url} 
                                                        alt="Poll image" 
                                                        className="max-w-full h-auto rounded-lg shadow-md"
                                                        style={{ maxHeight: '300px' }}
                                                    />
                                                </div>
                                            )}
                                            
                                            {/* Handle different poll types */}
                                            {currentAudiencePoll.poll_type === 'open_ended' ? (
                                                // Open Answer Poll
                                                <div className="mb-6">
                                                    <textarea 
                                                        value={selectedOption || ''}
                                                        onChange={(e) => setSelectedOption(e.target.value)}
                                                        disabled={hasSubmittedCurrentPoll || currentAudiencePoll.poll_status !== 'active'}
                                                        placeholder="Type your answer here..."
                                                        className="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-1 focus:ring-indigo-500 focus:border-indigo-500 disabled:bg-gray-100 disabled:text-gray-500"
                                                        rows={4}
                                                    />
                                                    
                                                    {/* Submit Button for Open Answer */}
                                                    {currentAudiencePoll.poll_status === 'active' && !hasSubmittedCurrentPoll && (
                                                        <button
                                                            onClick={() => handleSubmitOpenAnswer(currentAudiencePoll.id, selectedOption)}
                                                            disabled={!selectedOption}
                                                            className="w-full mt-4 bg-green-600 text-white px-4 py-2 rounded-md font-medium hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-colors duration-150 disabled:opacity-50 disabled:cursor-not-allowed"
                                                        >
                                                            Submit Answer
                                                        </button>
                                                    )}
                                                </div>
                                            ) : (
                                                // Multiple/Single Choice Poll
                                          <div className="space-y-3 mb-6">
                                                    {currentAudiencePoll.options.map((option, index) => (
                                                  <div
                                                            key={index}
                                                      onClick={() => handleSelectOption(option)}
                                                      className={classNames(
                                                          'poll-option',
                                                                selectedOption === option && !hasSubmittedCurrentPoll && currentAudiencePoll.poll_status === 'active' && 'selected',
                                                          // Disable interaction visually if submitted or not active
                                                                (hasSubmittedCurrentPoll || currentAudiencePoll.poll_status !== 'active') && 'disabled submitted'
                                                      )}
                                                  >
                                                      {option}
                                                  </div>
                                              ))}

                                                    {/* Submit Button for Multiple/Single Choice */}
                                                    {currentAudiencePoll.poll_status === 'active' && !hasSubmittedCurrentPoll && (
                                              <button
                                                            onClick={() => handleSubmitVote(currentAudiencePoll.id)}
                                                  disabled={!selectedOption}
                                                            className="w-full mt-4 bg-green-600 text-white px-4 py-2 rounded-md font-medium hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-colors duration-150 disabled:opacity-50 disabled:cursor-not-allowed"
                                              >
                                                  Submit Answer
                                              </button>
                                          )}
                                                </div>
                                            )}
                                            
                                          {/* Submitted Message */}
                                            {hasSubmittedCurrentPoll && (
                                              <p className="text-center text-green-700 font-medium bg-green-100 p-3 rounded-md">Your answer for this poll has been submitted!</p>
                                          )}
                                            
                                          {/* Ended Message (if not submitted) */}
                                            {currentAudiencePoll.poll_status === 'ended' && !hasSubmittedCurrentPoll && (
                                               <p className="text-center text-red-700 font-medium bg-red-100 p-3 rounded-md">This poll has ended.</p>
                                          )}

                                          {/* Results (Show only if poll status is 'ended') */}
                                            {currentAudiencePoll.poll_status === 'ended' && (
                                                <div className="mt-6 border-t pt-4 border-gray-200">
                                                    <h4 className="text-lg font-medium text-gray-800 mb-3">Poll Results</h4>
                                                    {currentAudiencePoll.poll_type === 'open_ended' ? (
                                                        // Open Answer Results
                                                        <div className="space-y-2">
                                                            <p className="text-center text-gray-500">
                                                                Open answer responses:
                                                            </p>
                                                            {/* Display open answers from results */}
                                                            {pollResults[currentAudiencePoll.id]?.results?.length > 0 ? (
                                                                <div className="space-y-2">
                                                                    {pollResults[currentAudiencePoll.id].results.map((answer, index) => (
                                                                        <div key={index} className="bg-gray-50 p-3 rounded-md">
                                                                            <p className="text-gray-800">{answer.answer_text}</p>
                                                                            <p className="text-xs text-gray-500 mt-1">User ID: {answer.user_id}</p>
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                            ) : (
                                                                <div className="bg-gray-50 p-4 rounded-lg">
                                                                    <p className="text-sm italic text-gray-500">
                                                                        No responses have been submitted yet.
                                                                    </p>
                                                                </div>
                                                            )}
                                                        </div>
                                                    ) : (
                                                        // Multiple/Single Choice Results
                                                        <div className="space-y-3">
                                                            {currentAudiencePoll.options.map((option, index) => {
                                                                // Calculate votes from the results data
                                                                const votes = pollResults[currentAudiencePoll.id]?.results || [];
                                                                const voteCount = votes.filter(vote => 
                                                                    parseInt(vote.selected_option_index) === index
                                                                ).length;
                                                                
                                                                const totalVotes = votes.length;
                                                                const percentage = totalVotes > 0 ? ((voteCount / totalVotes) * 100).toFixed(1) : 0;
                                                                
                                                                return (
                                                                    <div key={index} className="w-full">
                                                                        <div className="flex justify-between items-center mb-1">
                                                                            <span className="text-sm font-medium text-gray-700">{option}</span>
                                                                            <span className="text-sm text-gray-500">{voteCount} vote(s)</span>
                                                                        </div>
                                                                        <div className="result-bar-bg">
                                                                            <div className="result-bar" style={{ width: `${percentage}%` }}>
                                                                                <span className="result-percentage">{percentage}%</span>
                                                                            </div>
                                                                            <span className="result-label">{option}</span>
                                                                        </div>
                                                                    </div>
                                                                );
                                                            })}
                                                            <p className="text-sm text-center text-gray-500 mt-2">
                                                                Total votes: {pollResults[currentAudiencePoll.id]?.results?.length || 0}
                                                            </p>
                                                        </div>
                                                    )}
                                                </div>
                                            )}
                                        </>
                                  )}
                              </div>
                            )
                          )
                      )}
                  </div>
              </div>
          );
      }
      // ## End Poll Tool Components ##
        
      // --- ToolList and App components remain the same ---
      function ToolList({ onSelectTool }) { /* ... ToolList component code ... */
         const tools = [ { id: 'raise-hand', name: 'Raise Hand (Q&A)', description: 'Ask questions, vote, and get answers.' }, { id: 'poll', name: 'Poll', description: 'Create and participate in live polls. (Coming Soon)' }, { id: 'find-teammate', name: 'Find Teammate', description: 'Connect with peers for group projects. (Coming Soon)' }, ];
         return ( <div className="min-h-screen bg-gradient-to-br from-indigo-100 via-purple-50 to-pink-100 flex items-center justify-center p-6 font-sans"> <div className="w-full max-w-2xl bg-white rounded-xl shadow-lg p-8"> <h1 className="text-3xl font-bold text-center text-gray-800 mb-8">Professor & Student Tools</h1> <div className="space-y-4"> {tools.map(tool => ( <button key={tool.id} onClick={() => onSelectTool(tool.id)} className="w-full text-left p-5 border border-gray-200 rounded-lg hover:bg-gray-100 hover:shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50 transition duration-150 ease-in-out" > <h2 className="text-xl font-semibold text-indigo-700">{tool.name}</h2> <p className="text-gray-600 mt-1">{tool.description}</p> </button> ))} </div> </div> </div> );
      }
      function App() { /* ... App component code remains the same ... */
        const [currentTool, setCurrentTool] = useState(null);
        const handleSelectTool = (toolId) => { if (toolId === 'raise-hand' || toolId === 'poll') { setCurrentTool(toolId); } else { alert(`Tool "${toolId}" is not yet implemented.`); } };
        const handleGoBack = () => { setCurrentTool(null); };
        if (currentTool === 'raise-hand') { return <RaiseHandTool onGoBack={handleGoBack} />; }
        if (currentTool === 'poll') { return <PollTool onGoBack={handleGoBack} />; }
        return <ToolList onSelectTool={handleSelectTool} />;
      }

      // --- Render the App ---
      const container = document.getElementById('root');
      const root = ReactDOM.createRoot(container);
      root.render(<App />);

    </script>
</body>
</html>
