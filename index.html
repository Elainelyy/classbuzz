<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professor/Student Tools</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/react-image-crop/dist/ReactCrop.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/react-image-crop/dist/ReactCrop.css">
    <style>
        body { margin: 0; font-family: 'Inter', sans-serif; background-color: #f9fafb; }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        .dot { box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        /* Basic loading/error message styling */
        .message-box {
            text-align: center;
            padding: 20px;
            margin-top: 20px;
            border-radius: 8px;
        }
        .loading { background-color: #e0f2fe; color: #0c4a6e; }
        .error { background-color: #fee2e2; color: #991b1b; }
        .error-inline { color: #991b1b; font-size: 0.875rem; margin-top: 0.5rem; }
        /* Poll specific styles */
        .poll-option { cursor: pointer; border: 1px solid #e5e7eb; padding: 0.75rem 1rem; border-radius: 0.375rem; transition: background-color 0.15s ease-in-out, border-color 0.15s ease-in-out; }
        .poll-option:hover { background-color: #f9fafb; }
        .poll-option.selected { background-color: #e0e7ff; border-color: #a5b4fc; }
        /* Add style for non-active polls in audience view */
        .poll-option.disabled { cursor: not-allowed; background-color: #f9fafb; color: #9ca3af; }
        .poll-option.submitted { cursor: default; }
         /* Simple bar chart for results */
        .result-bar-bg { background-color: #e5e7eb; height: 1.5rem; border-radius: 0.375rem; overflow: hidden; position: relative; }
        .result-bar { background-color: #6366f1; height: 100%; transition: width 0.3s ease-out; display: flex; align-items: center; justify-content: flex-end; padding-right: 0.5rem; color: white; font-size: 0.75rem; }
        .result-label { position: absolute; left: 0.5rem; top: 50%; transform: translateY(-50%); font-size: 0.875rem; color: #4b5563; }
        .result-percentage { font-weight: 500; }
        /* Poll List Item Styling */
        .poll-list-item { border: 1px solid #e5e7eb; padding: 1rem; border-radius: 0.5rem; background-color: white; margin-bottom: 0.75rem; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.75rem; }
        .poll-list-item .status-badge { font-size: 0.75rem; padding: 0.125rem 0.5rem; border-radius: 0.375rem; font-weight: 500; text-transform: uppercase; }
        .poll-list-item .status-idle { background-color: #d1d5db; color: #4b5563; }
        .poll-list-item .status-active { background-color: #a7f3d0; color: #047857; }
        .poll-list-item .status-ended { background-color: #fecaca; color: #b91c1c; }
        .poll-editor {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .form-group input[type="text"],
        .form-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }

        .image-upload-container {
            margin-top: 10px;
        }

        .image-preview {
            max-width: 200px;
            max-height: 200px;
            margin-top: 10px;
            border-radius: 4px;
        }

        .remove-image {
            display: none;
        }

        .upload-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
        }

        .upload-button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }

        .option-input {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .option-input input {
            flex: 1;
        }

        .form-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: flex-end;
        }

        .form-actions button {
            padding: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .form-actions button[type="submit"] {
            background: #4CAF50;
            color: white;
        }

        .form-actions button[type="button"] {
            background: #f44336;
            color: white;
        }

        .image-crop-container {
            max-width: 100%;
            margin: 20px 0;
            position: relative;
            background: #f9fafb;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .image-crop-container img {
            max-width: 100%;
            max-height: 400px;
            display: block;
            margin: 0 auto;
        }

        .crop-controls {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .crop-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }

        .crop-button:hover {
            background: #45a049;
        }

        .image-preview-container {
            margin: 20px 0;
            text-align: center;
        }

        .image-preview {
            max-width: 200px;
            max-height: 200px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .upload-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            margin-right: 10px;
        }

        .upload-button:hover {
            background: #45a049;
        }

        .remove-image {
            background: #f44336;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }

        .remove-image:hover {
            background: #d32f2f;
        }
     </style>
</head>
<body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <script type="text/babel">
      const { useState, useEffect, useMemo, useCallback, useRef } = React;
      
      // Initialize ReactCrop after ensuring it's loaded
      const ReactCrop = window.ReactCrop ? window.ReactCrop.default : null;

      // Base URL for API - relative to current domain
      const API_BASE_URL = '';

      // --- Utility Functions ---
      function classNames(...classes) { return classes.filter(Boolean).join(' '); }

      // --- Mock Data ---
      const initialPollsData = [
          { id: 'p1', question: 'What is your favorite programming language?', options: ['JavaScript', 'Python', 'Java', 'C++'], results: { 'JavaScript': 15, 'Python': 25, 'Java': 8, 'C++': 5 }, userAnswers: {}, totalVotes: 53 , status: 'idle'}, // Store user answers keyed by a user ID (simulated)
          { id: 'p2', question: 'Which topic should we cover next week?', options: ['Async/Await', 'Database Indexing', 'WebSockets'], results: { 'Async/Await': 12, 'Database Indexing': 18, 'WebSockets': 9 }, userAnswers: {}, totalVotes: 39, status: 'idle'},
      ];
      // --- Components ---
      function Comment({ comment }) {
        // Display relative time for comments (optional enhancement)
        // const timeAgo = /* Function to calculate time ago from comment.created_at */;
        return (
          <div className="ml-4 mt-2 p-2 bg-gray-100 rounded text-sm text-gray-700">
            <p>{comment.text}</p>
            {/* Optional: <span className="text-xs text-gray-500">{timeAgo}</span> */}
          </div>
        );
      }

      function Question({ question, onVote, onAddComment, onToggleAnswer, isSpeaker }) {
        const [showComments, setShowComments] = useState(false);
        const [newComment, setNewComment] = useState('');
        const [commentError, setCommentError] = useState(null); // State for comment errors

        // Use the actual comments array fetched from the backend
        const comments = question.comments || [];

        const handleAddCommentSubmit = async (e) => {
          e.preventDefault();
          const trimmedComment = newComment.trim();
          if (!trimmedComment) return;

          setCommentError(null); // Clear previous errors
          try {
            // Call the async function passed down from RaiseHandTool
            await onAddComment(question.id, trimmedComment);
            setNewComment(''); // Clear input on success
            setShowComments(true); // Keep comments open
          } catch (error) {
            console.error("Failed to add comment:", error);
            setCommentError(error.message || "Failed to post comment. Please try again.");
          }
        };


        return (
          <div className={classNames( "border rounded-lg p-4 mb-4 shadow-sm transition-colors duration-200", question.is_answered ? 'bg-green-50 border-green-200' : 'bg-white border-gray-200 hover:bg-gray-50' )}>
            <div className="flex items-start justify-between gap-4">
              <div className="flex-grow min-w-0">
                <p className={classNames( "text-gray-800 break-words", question.is_answered ? 'line-through text-gray-500' : '' )}>
                  {question.text}
                </p>
                <div className="text-sm text-gray-500 mt-2 flex flex-wrap items-center gap-x-4 gap-y-1">
                  {/* Vote Button */}
                  <button onClick={() => onVote(question.id)} disabled={question.is_answered} className={classNames( "flex items-center px-2 py-1 rounded transition-colors duration-150", question.is_answered ? "text-gray-400 cursor-not-allowed" : "text-blue-600 hover:bg-blue-100 disabled:opacity-50" )} aria-label={`Vote for question: ${question.text}`} >
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V7z" clipRule="evenodd" /></svg>
                    <span>{question.votes} Vote{question.votes !== 1 ? 's' : ''}</span>
                  </button>
                  {/* Comment Toggle Button */}
                  <button onClick={() => setShowComments(!showComments)} className="flex items-center text-gray-600 hover:text-indigo-600 text-sm" aria-expanded={showComments} aria-controls={`comments-${question.id}`} >
                     <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" /></svg>
                     {comments.length} Comment{comments.length !== 1 ? 's' : ''}
                  </button>
                   {/* Answered Status Badge */}
                   {question.is_answered && (
                      <span className="text-green-600 font-medium text-xs inline-flex items-center bg-green-100 px-2 py-0.5 rounded-full">
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-3 w-3 mr-1" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" /></svg>
                        Answered
                      </span>
                    )}
                </div>
              </div>
              {/* Speaker Action Button */}
              {isSpeaker && ( <button onClick={() => onToggleAnswer(question.id, !question.is_answered)} className={classNames( "flex-shrink-0 text-sm font-medium px-3 py-1 rounded transition-colors duration-150 self-start", question.is_answered ? 'bg-yellow-100 text-yellow-700 hover:bg-yellow-200' : 'bg-green-100 text-green-700 hover:bg-green-200' )} > {question.is_answered ? 'Mark Unanswered' : 'Mark Answered'} </button> )}
            </div>

            {/* Comments Section */}
            {showComments && (
              <div id={`comments-${question.id}`} className="mt-3 pl-4 border-l-2 border-gray-200">
                {comments.length > 0 ? (
                  comments.map(comment => <Comment key={comment.id} comment={comment} />)
                ) : ( <p className="text-sm text-gray-500 italic">No comments yet.</p> )}
                <form onSubmit={handleAddCommentSubmit} className="mt-3 flex items-center">
                  <input type="text" value={newComment} onChange={(e) => setNewComment(e.target.value)} placeholder="Add a comment..." className="flex-grow border border-gray-300 rounded-l px-3 py-1.5 text-sm focus:outline-none focus:ring-1 focus:ring-indigo-500 focus:border-indigo-500" aria-label="Add a comment to this question" />
                  <button type="submit" className="bg-indigo-600 text-white px-3 py-1.5 rounded-r text-sm font-medium hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-indigo-500 transition-colors duration-150 disabled:opacity-50" disabled={!newComment.trim()} > Add </button>
                </form>
                {commentError && <p className="error-inline">{commentError}</p>}
              </div>
            )}
          </div>
        );
      }

      /**
       * The main view for the "Raise Hand" tool.
       */
      function RaiseHandTool({ onGoBack }) {
        const [questions, setQuestions] = useState([]);
        const [isLoading, setIsLoading] = useState(true);
        const [error, setError] = useState(null);
        const [newQuestion, setNewQuestion] = useState('');
        const [isSpeaker, setIsSpeaker] = useState(false);

        // --- Fetch Questions (includes comments now - requires backend update) ---
        const fetchQuestions = useCallback(async () => {
          setIsLoading(true);
          setError(null);
          try {
            const response = await fetch(`${API_BASE_URL}/api/questions`); // Assume this now returns comments too
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            const questionsWithDates = data.map(q => ({
                ...q,
                createdAt: new Date(q.created_at),
                // Ensure comments have dates parsed if needed
                comments: (q.comments || []).map(c => ({ ...c, createdAt: new Date(c.created_at) }))
            }));
            setQuestions(questionsWithDates);
          } catch (e) {
            console.error("Failed to fetch questions:", e);
            setError("Failed to load questions. Please try again later.");
          } finally {
            setIsLoading(false);
          }
        }, []);

        useEffect(() => {
          fetchQuestions();
        }, [fetchQuestions]);

        // --- Add Question ---
        const handleAddQuestion = async (e) => {
          e.preventDefault();
          const trimmedQuestion = newQuestion.trim();
          if (!trimmedQuestion) return;
          const originalQuestions = questions; // Store state for potential revert
          setNewQuestion(''); // Clear input immediately

          // Optimistic update (optional)
          // const tempId = `temp-${Date.now()}`;
          // setQuestions(prev => [{ id: tempId, text: trimmedQuestion, votes: 0, is_answered: false, createdAt: new Date(), comments: [] }, ...prev]);

          try {
            const response = await fetch(`${API_BASE_URL}/api/questions`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ text: trimmedQuestion }),
            });
            if (!response.ok) {
              const errorData = await response.json();
              throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
            }
            const addedQuestion = await response.json();
            // Replace optimistic update or just add if not doing optimistic
            // Ensure comments array exists and dates are parsed
            const newQ = {
                ...addedQuestion,
                createdAt: new Date(addedQuestion.created_at),
                comments: (addedQuestion.comments || []).map(c => ({ ...c, createdAt: new Date(c.created_at) }))
            };
            // Add to the top of the list
             setQuestions(prevQuestions => [newQ, ...prevQuestions]);
             // If using optimistic: setQuestions(prev => prev.map(q => q.id === tempId ? newQ : q));

          } catch (e) {
            console.error("Failed to add question:", e);
            setError(`Failed to add question: ${e.message}. Please try again.`);
            setNewQuestion(trimmedQuestion); // Restore input on error
            // Revert optimistic update if used
            // setQuestions(originalQuestions);
          }
        };

        // --- Vote ---
        const handleVote = useCallback(async (questionId) => {
          // Optimistic update
          const originalQuestions = questions;
          setQuestions(prevQuestions =>
            prevQuestions.map(q =>
              q.id === questionId ? { ...q, votes: q.votes + 1 } : q
            )
          );

          try {
            const response = await fetch(`${API_BASE_URL}/api/questions/${questionId}/vote`, { method: 'POST' }); // Assuming POST endpoint
            if (!response.ok) {
                // Revert optimistic update on failure
                setQuestions(originalQuestions);
                const errorData = await response.json().catch(() => ({})); // Try to get error message
                throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
            }
            // Optional: Refetch or update state with response data if needed,
            // but optimistic update might be sufficient if backend just confirms success.
          } catch (e) {
            console.error("Failed to vote:", e);
            setError(`Vote failed: ${e.message}`);
            // Ensure state is reverted if fetch failed before parsing response
            setQuestions(originalQuestions);
          }
        }, [questions]); // Include questions to get latest state for revert

        // --- Add Comment ---
        const handleAddComment = useCallback(async (questionId, commentText) => {
          // Note: Optimistic update is handled partially in the Question component for temp display.
          // This function focuses on the API call. We expect it to throw on error.
          const response = await fetch(`${API_BASE_URL}/api/questions/${questionId}/comments`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ text: commentText }),
          });

          if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
          }

          const newComment = await response.json();

          // Update the specific question's comments array with the real comment from the backend
          setQuestions(prevQuestions =>
            prevQuestions.map(q =>
              q.id === questionId
                ? {
                    ...q,
                    comments: [
                        ...(q.comments || []), // Ensure comments array exists
                        { ...newComment, createdAt: new Date(newComment.created_at) } // Add the new comment with parsed date
                    ].sort((a, b) => new Date(a.created_at) - new Date(b.created_at)) // Keep comments sorted
                  }
                : q
            )
          );
          // Let the Question component handle clearing input etc. via try/catch around this call
        }, []); // No dependency on questions state needed here directly

        // --- Toggle Answer ---
        const handleToggleAnswer = useCallback(async (questionId, newAnsweredState) => {
          if (!isSpeaker) return;
          const originalQuestions = questions;

          // Optimistic update
          setQuestions(prevQuestions =>
            prevQuestions.map(q =>
              q.id === questionId ? { ...q, is_answered: newAnsweredState } : q
            )
          );

          try {
            const response = await fetch(`${API_BASE_URL}/api/questions/${questionId}/answer`, { // Assuming PATCH endpoint
              method: 'PATCH',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ is_answered: newAnsweredState }),
            });
             if (!response.ok) {
                setQuestions(originalQuestions); // Revert
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
            }
            // Optional: update state with response data if backend modifies it further
          } catch (e) {
            console.error("Failed to toggle answer status:", e);
            setError(`Update failed: ${e.message}`);
            setQuestions(originalQuestions); // Revert
          }
        }, [isSpeaker, questions]); // Include questions for revert, isSpeaker for check


        // --- Sorting Logic (remains the same) ---
        const sortedQuestions = useMemo(() => {
          return [...questions].sort((a, b) => {
            if (a.is_answered !== b.is_answered) { return a.is_answered ? 1 : -1; }
            if (b.votes !== a.votes) { return b.votes - a.votes; }
            const dateA = a.createdAt instanceof Date ? a.createdAt.getTime() : 0;
            const dateB = b.createdAt instanceof Date ? b.createdAt.getTime() : 0;
            return dateA - dateB;
          });
        }, [questions]);

        // --- Render UI ---
        return (
          <div className="p-4 sm:p-6 bg-gray-50 min-h-screen font-sans relative">
             <button onClick={onGoBack} className="absolute top-4 left-4 z-10 bg-white text-indigo-600 px-3 py-1 rounded-md shadow text-sm font-medium hover:bg-indigo-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" aria-label="Go back to tool list" > &larr; Back to Tools </button>
             <div className="max-w-3xl mx-auto bg-white p-6 rounded-lg shadow-md mt-12 sm:mt-16">
                {/* Header and Speaker Toggle */}
                <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-6 pb-4 border-b border-gray-200 gap-4">
                  <h2 className="text-2xl font-semibold text-gray-800 flex-shrink-0">Raise Hand / Q&A</h2>
                  <label className="flex items-center cursor-pointer flex-shrink-0">
                    <span className="mr-2 text-sm font-medium text-gray-700">Speaker Mode:</span>
                    <div className="relative">
                      <input type="checkbox" className="sr-only peer" checked={isSpeaker} onChange={() => setIsSpeaker(!isSpeaker)} id="speaker-toggle" />
                      <div className="w-10 h-6 rounded-full transition bg-gray-300 peer-checked:bg-indigo-600"></div>
                      <div className="absolute left-1 top-1 bg-white w-4 h-4 rounded-full transition transform peer-checked:translate-x-4 dot"></div>
                    </div>
                  </label>
                </div>
                {/* Add Question Form */}
                <form onSubmit={handleAddQuestion} className="mb-6 flex flex-col sm:flex-row gap-2">
                  <input type="text" value={newQuestion} onChange={(e) => setNewQuestion(e.target.value)} placeholder="Ask a question..." className="flex-grow border border-gray-300 rounded-md px-4 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500" aria-label="Ask a new question" />
                  <button type="submit" className="bg-indigo-600 text-white px-4 py-2 rounded-md font-medium hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-colors duration-150 disabled:opacity-50" disabled={!newQuestion.trim()} > Ask </button>
                </form>
                 {/* Display Top-Level Error */}
                 {error && <div className="message-box error mb-4">{error}</div>}

                {/* Display Loading / Questions List */}
                <div className="space-y-4">
                   <h3 className="text-lg font-medium text-gray-700 mb-2">Questions</h3>
                   {isLoading && <div className="message-box loading">Loading questions...</div>}
                   {!isLoading && !error && sortedQuestions.length === 0 && (
                       <p className="text-gray-500 italic text-center py-4">No questions asked yet. Be the first!</p>
                   )}
                   {!isLoading && !error && sortedQuestions.length > 0 && (
                      sortedQuestions.map(question => (
                        <Question
                          key={question.id}
                          question={question}
                          onVote={handleVote} // Pass down the updated handlers
                          onAddComment={handleAddComment}
                          onToggleAnswer={handleToggleAnswer}
                          isSpeaker={isSpeaker}
                        />
                      ))
                   )}
                </div>
             </div>
          </div>
        );
      }

      // ## Poll Tool Components ##

      function PollResults({ results, totalVotes, options }) { /* ... PollResults component code ... */
        if (totalVotes === 0) { return <p className="text-sm text-gray-500 italic mt-4">No votes yet.</p>; }
        return ( <div className="mt-6 space-y-3"> <h4 className="font-medium text-gray-700">Results ({totalVotes} total votes):</h4> {options.map(option => { const count = results[option] || 0; const percentage = totalVotes > 0 ? ((count / totalVotes) * 100).toFixed(1) : 0; return ( <div key={option} className="result-bar-bg"> <span className="result-label">{option}</span> <div className="result-bar" style={{ width: `${percentage}%` }}> <span className="result-percentage">{percentage}%</span>&nbsp;({count}) </div> </div> ); })} </div> );
      }

      function PollEditor({ onSave, onCancel, initialData }) {
        const [question, setQuestion] = useState(initialData?.question || '');
        const [options, setOptions] = useState(initialData?.options || ['', '']);
        const [pollType, setPollType] = useState(initialData?.poll_type || 'single_choice');
        const [image, setImage] = useState(initialData?.image_url || null);
        const [imagePreview, setImagePreview] = useState(initialData?.image_url || null);
        const [isCropping, setIsCropping] = useState(false);
        const [crop, setCrop] = useState({ aspect: 16 / 9 });
        const [croppedImage, setCroppedImage] = useState(null);
        const imageRef = useRef(null);
        const fileInputRef = useRef(null);

        const handleImageUpload = (e) => {
          const file = e.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
              setImage(e.target.result);
              setImagePreview(e.target.result);
              setIsCropping(true);
            };
            reader.readAsDataURL(file);
          }
        };

        const handleCropComplete = (croppedArea, croppedAreaPixels) => {
          if (!image || !croppedAreaPixels) return;

          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          const imageObj = new Image();

          imageObj.onload = () => {
            canvas.width = croppedAreaPixels.width;
            canvas.height = croppedAreaPixels.height;

            ctx.drawImage(
              imageObj,
              croppedAreaPixels.x,
              croppedAreaPixels.y,
              croppedAreaPixels.width,
              croppedAreaPixels.height,
              0,
              0,
              croppedAreaPixels.width,
              croppedAreaPixels.height
            );

            const croppedImageUrl = canvas.toDataURL('image/jpeg');
            setCroppedImage(croppedImageUrl);
            setImagePreview(croppedImageUrl);
          };

          imageObj.src = image;
        };

        const handleSubmit = (e) => {
          e.preventDefault();
          
          // Validate that either question or image is provided
          if (!question.trim() && !image) {
            alert('Please provide either a question or an image');
            return;
          }

          if (pollType === 'open_ended') {
            onSave({
              question: question.trim(),
              options: null,
              pollType,
              imageUrl: image
            });
            return;
          }

          // Validate options
          const validOptions = options.filter(opt => opt.trim() !== '');
          if (validOptions.length < 2) {
            alert('Please provide at least two options');
            return;
          }

          onSave({
            question: question.trim(),
            options: validOptions,
            pollType,
            imageUrl: image
          });
        };

        return (
          <div className="poll-editor">
            <h2>{initialData ? 'Edit Poll' : 'Create New Poll'}</h2>
            <form onSubmit={handleSubmit}>
              <div className="form-group">
                <label>Question (optional if image is provided):</label>
                <input
                  type="text"
                  value={question}
                  onChange={(e) => setQuestion(e.target.value)}
                />
              </div>

              <div className="form-group">
                <label>Image (optional if question is provided):</label>
                <div className="image-upload-container">
                  {imagePreview && (
                    <div className="image-preview-container">
                      <img src={imagePreview} alt="Preview" className="image-preview" />
                    </div>
                  )}
                  
                  {isCropping && image && ReactCrop && (
                    <div className="image-crop-container">
                      <ReactCrop.default
                        crop={crop}
                        onChange={(c) => setCrop(c)}
                        onComplete={handleCropComplete}
                        aspect={16/9}
                      >
                        <img src={image} ref={imageRef} alt="Crop" />
                      </ReactCrop.default>
                      <div className="crop-controls">
                        <button
                          type="button"
                          onClick={() => setIsCropping(false)}
                          className="crop-button"
                        >
                          Done Cropping
                        </button>
                      </div>
                    </div>
                  )}

                  <div style={{ marginTop: '10px' }}>
                    <input
                      type="file"
                      ref={fileInputRef}
                      accept="image/*"
                      onChange={handleImageUpload}
                      style={{ display: 'none' }}
                    />
                    <button
                      type="button"
                      className="upload-button"
                      onClick={() => fileInputRef.current?.click()}
                    >
                      {imagePreview ? 'Replace Image' : 'Upload Image'}
                    </button>
                    {imagePreview && (
                      <button
                        type="button"
                        onClick={() => {
                          setImage(null);
                          setImagePreview(null);
                          setIsCropping(false);
                        }}
                        className="remove-image"
                      >
                        Remove
                      </button>
                    )}
                  </div>
                </div>
              </div>

              <div className="form-group">
                <label>Poll Type</label>
                <select value={pollType} onChange={(e) => setPollType(e.target.value)}>
                  <option value="single_choice">Single Choice</option>
                  <option value="multiple_choice">Multiple Choice</option>
                  <option value="open_ended">Open Ended</option>
                </select>
              </div>

              {pollType !== 'open_ended' && (
                <div className="form-group">
                  <label>Options</label>
                  {options.map((option, index) => (
                    <div key={index} className="option-input">
                      <input
                        type="text"
                        value={option}
                        onChange={(e) => {
                          const newOptions = [...options];
                          newOptions[index] = e.target.value;
                          setOptions(newOptions);
                        }}
                        placeholder={`Option ${index + 1}`}
                        required
                      />
                      {options.length > 2 && (
                        <button
                          type="button"
                          onClick={() => {
                            const newOptions = options.filter((_, i) => i !== index);
                            setOptions(newOptions);
                          }}
                          className="remove-option"
                        >
                          Ã—
                        </button>
                      )}
                    </div>
                  ))}
                  <button
                    type="button"
                    onClick={() => setOptions([...options, ''])}
                    className="add-option"
                  >
                    Add Option
                  </button>
                </div>
              )}

              <div className="form-actions">
                <button type="button" onClick={onCancel} className="cancel-button">
                  Cancel
                </button>
                <button type="submit" className="save-button">
                  {initialData ? 'Update Poll' : 'Create Poll'}
                </button>
              </div>
            </form>
          </div>
        );
      }


      /**
       * The main view for the "Poll" tool - Updated Speaker View & Audience Navigation.
       */
      function PollTool({ onGoBack }) {
          const [polls, setPolls] = useState([]);
          const [isSpeaker, setIsSpeaker] = useState(false);
          const [submittedAnswers, setSubmittedAnswers] = useState({});
          const [editingPollId, setEditingPollId] = useState(null);
          const [isLoading, setIsLoading] = useState(true);
          const [error, setError] = useState(null);
          const [selectedOption, setSelectedOption] = useState(null);
          const [pollResults, setPollResults] = useState({});
          
          // For audience navigation
          const [currentAudiencePollIndex, setCurrentAudiencePollIndex] = useState(0);

          // Filter polls for audience view (Active or Ended only)
          const visibleAudiencePolls = useMemo(() => 
            polls.filter(p => p.poll_status === 'active' || p.poll_status === 'ended'), 
            [polls]
          );

          // Get the specific poll the audience is currently viewing
          const currentAudiencePoll = visibleAudiencePolls[currentAudiencePollIndex];
          
          // Check submission status for current poll
          const hasSubmittedCurrentPoll = currentAudiencePoll ? submittedAnswers[currentAudiencePoll.id] : false;

          // Reset audience selection when viewed poll changes
          useEffect(() => {
            // Ensure index is valid when the list of visible polls changes
            const newIndex = Math.min(currentAudiencePollIndex, Math.max(0, visibleAudiencePolls.length - 1));
            if (newIndex !== currentAudiencePollIndex && visibleAudiencePolls.length > 0) {
                // Only update index if it's actually out of bounds AND there are visible polls
                setCurrentAudiencePollIndex(newIndex);
            } else if (visibleAudiencePolls.length === 0 && currentAudiencePollIndex !== 0) {
                // Reset index if the list becomes empty
                setCurrentAudiencePollIndex(0);
            }
            
            // Reset selection for the new poll
            setSelectedOption(null);
          }, [currentAudiencePollIndex, visibleAudiencePolls]);

          // Fetch polls from the API
          const fetchPolls = useCallback(async () => {
            setIsLoading(true);
            setError(null);
            try {
              const response = await fetch(`${API_BASE_URL}/api/polls`);
              if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
              const data = await response.json();
              setPolls(data);
            } catch (e) {
              console.error("Failed to fetch polls:", e);
              setError("Failed to load polls. Please try again later.");
            } finally {
              setIsLoading(false);
            }
          }, []);

          useEffect(() => {
            fetchPolls();
          }, [fetchPolls]);

          // Fetch poll results when needed
          useEffect(() => {
            if (currentAudiencePoll && currentAudiencePoll.poll_status === 'ended' && !pollResults[currentAudiencePoll.id]) {
              fetchPollResults(currentAudiencePoll.id);
            }
          }, [currentAudiencePoll]);
          
          // Function to fetch poll results
          const fetchPollResults = async (pollId) => {
            try {
              const response = await fetch(`${API_BASE_URL}/api/polls/${pollId}/results`);
              if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
              const data = await response.json();
              setPollResults(prev => ({
                ...prev,
                [pollId]: data
              }));
            } catch (e) {
              console.error(`Failed to fetch results for poll ${pollId}:`, e);
              // We don't set the global error state here to avoid disrupting the UI
            }
          };

          // Function to handle edit poll button click
          const handleEditPoll = (poll) => {
            setEditingPollId(poll.id);
          };

          // Handle creating or updating a poll
          const handleSavePoll = async (pollData) => {
            try {
              setIsLoading(true);
              
              const isEditing = !!pollData.id;
              
              let url = `${API_BASE_URL}/api/polls`;
              let method = 'POST';
              
              if (isEditing) {
                url = `${API_BASE_URL}/api/polls/${pollData.id}`;
                method = 'PATCH';
              }

              // Validate options array
              if (pollData.pollType !== 'open_ended') {
                if (!pollData.options || !Array.isArray(pollData.options)) {
                  throw new Error('Options must be an array for non-open-ended polls');
                }
                const validOptions = pollData.options.filter(opt => opt.trim() !== '');
                if (validOptions.length < 2) {
                  throw new Error('At least two non-empty options are required');
                }
                if (new Set(validOptions).size !== validOptions.length) {
                  throw new Error('Duplicate options are not allowed');
                }
              } else {
                // For open-ended polls, ensure options is null
                pollData.options = null;
              }
              
              console.log(`${isEditing ? 'Updating' : 'Creating'} poll with data:`, {
                question: pollData.question,
                options: pollData.options,
                poll_type: pollData.pollType,
                image_url: pollData.imageUrl
              });
              
              const response = await fetch(url, {
                method: method,
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  question: pollData.question,
                  options: pollData.options,
                  poll_type: pollData.pollType,
                  image_url: pollData.imageUrl
                })
              });
              
              if (!response.ok) {
                const errorData = await response.json();
                console.error('Server error response:', errorData);
                throw new Error(errorData.error || 'Failed to save poll');
              }
              
              if (isEditing) {
                // Update the poll in the existing list
                const updatedPoll = await response.json();
                setPolls(polls.map(p => p.id === updatedPoll.id ? updatedPoll : p));
              } else {
                // Add the new poll to the list
                fetchPolls();
              }
              
              setEditingPollId(null);
            } catch (e) {
              console.error('Error saving poll:', e);
              setError(e.message);
            } finally {
              setIsLoading(false);
            }
          };

          // Handle updating poll status
          const handleTogglePollStatus = async (pollId) => {
            try {
              const currentPoll = polls.find(p => p.id === pollId);
              if (!currentPoll) return;

              let newStatus;
              if (currentPoll.poll_status === 'idle') newStatus = 'active';
              else if (currentPoll.poll_status === 'active') newStatus = 'ended';
              else newStatus = 'active'; // Change from 'idle' to 'active' for Resume functionality

              const response = await fetch(`${API_BASE_URL}/api/polls/${pollId}/status`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ status: newStatus })
              });
              if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
              const updatedPoll = await response.json();
              setPolls(prevPolls => prevPolls.map(p => p.id === pollId ? updatedPoll : p));
            } catch (e) {
              console.error("Failed to update poll status:", e);
              setError("Failed to update poll status. Please try again.");
            }
          };

          // Handle selecting an option (separate from submission)
          const handleSelectOption = (option) => {
            // Allow selection only if poll is active and not already submitted
            if (hasSubmittedCurrentPoll || !currentAudiencePoll || currentAudiencePoll.poll_status !== 'active') return;
            setSelectedOption(option);
          };

          // Handle submitting a vote
          const handleSubmitVote = async (pollId) => {
            if (!selectedOption && currentAudiencePoll?.poll_type !== 'open_ended') {
              alert("Please select an option first");
              return;
            }
            
            try {
              // Find the index of the selected option
              const optionIndex = currentAudiencePoll.options.indexOf(selectedOption);
              
              // TODO: Replace with real user authentication
              // Using a numeric userId as the backend expects an integer
              const tempUserId = 1
              
              console.log("Submitting vote:", { 
                pollId, 
                selectedOption,
                userId: tempUserId,
                selectedOptionIndex: optionIndex
              });
              
              if (optionIndex === -1 && currentAudiencePoll?.poll_type !== 'open_ended') {
                throw new Error("Selected option not found in poll options");
              }
              
              const response = await fetch(`${API_BASE_URL}/api/polls/${pollId}/vote`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  userId: tempUserId, // Using numeric ID for now
                  selectedOptionIndex: optionIndex
                })
              });
              
              if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                console.error("Server error response:", errorData);
                throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
              }
              
              setSubmittedAnswers(prev => ({ ...prev, [pollId]: true }));
              // Refresh polls to get updated vote counts
              fetchPolls();
            } catch (e) {
              console.error("Failed to submit vote:", e);
              setError("Failed to submit vote: " + (e.message || "Please try again."));
            }
          };

          // Handle submitting an open answer
          const handleSubmitOpenAnswer = async (pollId, answerText) => {
            if (!answerText) {
              alert("Please enter an answer");
              return;
            }
            
            try {
              // TODO: Replace with real user authentication
              // Using a numeric userId as the backend expects an integer
              const tempUserId = 1;
              
              console.log("Submitting open answer:", { 
                pollId, 
                answerText,
                userId: tempUserId 
              });
              
              const response = await fetch(`${API_BASE_URL}/api/polls/${pollId}/open-answer`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  userId: tempUserId, // Using numeric ID for now
                  answerText: answerText
                })
              });
              
              if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                console.error("Server error response:", errorData);
                throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
              }
              
              setSubmittedAnswers(prev => ({ ...prev, [pollId]: true }));
              setSelectedOption(null);
              // Refresh polls to get updated answers
              fetchPolls();
            } catch (e) {
              console.error("Failed to submit answer:", e);
              setError("Failed to submit answer: " + (e.message || "Please try again."));
            }
          };

          // Audience Navigation Handlers
          const handleAudienceNextPoll = () => {
            if (currentAudiencePollIndex < visibleAudiencePolls.length - 1) {
                setCurrentAudiencePollIndex(prev => prev + 1);
            }
          };
          
          const handleAudiencePrevPoll = () => {
            if (currentAudiencePollIndex > 0) {
                setCurrentAudiencePollIndex(prev => prev - 1);
            }
          };

          // Handle deleting a poll
          const handleDeletePoll = async (pollId) => {
            if (!confirm("Are you sure you want to delete this poll? This action cannot be undone.")) {
              return; // User canceled the deletion
            }
            
            try {
              const response = await fetch(`${API_BASE_URL}/api/polls/${pollId}`, {
                method: 'DELETE',
                headers: { 'Content-Type': 'application/json' }
              });
              
              if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                console.error("Server error response:", errorData);
                throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
              }
              
              // Remove the deleted poll from state
              setPolls(prevPolls => prevPolls.filter(p => p.id !== pollId));
            } catch (e) {
              console.error("Failed to delete poll:", e);
              setError("Failed to delete poll: " + (e.message || "Please try again."));
            }
          };

          // --- Render Logic ---
          return (
              <div className="p-4 sm:p-6 bg-gray-50 min-h-screen font-sans relative">
                  <button onClick={onGoBack} className="absolute top-4 left-4 z-10 bg-white text-indigo-600 px-3 py-1 rounded-md shadow text-sm font-medium hover:bg-indigo-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" aria-label="Go back to tool list">
                      &larr; Back to Tools
                  </button>

                  <div className="max-w-3xl mx-auto bg-white p-6 rounded-lg shadow-md mt-12 sm:mt-16">
                      {/* Header & Speaker Toggle */}
                      <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-6 pb-4 border-b border-gray-200 gap-4">
                          <h2 className="text-2xl font-semibold text-gray-800 flex-shrink-0">Poll Tool</h2>
                          <label className="flex items-center cursor-pointer flex-shrink-0">
                              <span className="mr-2 text-sm font-medium text-gray-700">Speaker Mode:</span>
                              <div className="relative">
                                  <input type="checkbox" className="sr-only peer" checked={isSpeaker} onChange={() => { 
                                      setIsSpeaker(!isSpeaker); 
                                      setEditingPollId(null);
                                      setCurrentAudiencePollIndex(0); // Reset index when switching modes
                                  }} id="poll-speaker-toggle" />
                                  <div className="w-10 h-6 rounded-full transition bg-gray-300 peer-checked:bg-indigo-600"></div>
                                  <div className="absolute left-1 top-1 bg-white w-4 h-4 rounded-full transition transform peer-checked:translate-x-4 dot"></div>
                              </div>
                          </label>
                      </div>

                      {/* Loading and Error States */}
                      {isLoading ? (
                        <div className="message-box loading">
                          <p>Loading polls...</p>
                        </div>
                      ) : error ? (
                        <div className="message-box error">
                          <p>{error}</p>
                          <button 
                            onClick={fetchPolls}
                            className="mt-2 bg-red-100 text-red-800 px-4 py-2 rounded"
                          >
                            Try Again
                          </button>
                        </div>
                      ) : (
                        /* Main Content */
                        isSpeaker ? (
                            // --- Speaker View ---
                            <div>
                                {editingPollId !== null ? (
                                    // Show Editor when creating or editing
                                    <PollEditor 
                                        key={editingPollId} 
                                        initialData={editingPollId === 'new' ? null : polls.find(p => p.id === editingPollId)} 
                                        onSave={handleSavePoll} 
                                        onCancel={() => setEditingPollId(null)} 
                                    />
                                ) : (
                                    // Show Poll List and Create Button when not editing
                                    <div>
                                        <button onClick={() => setEditingPollId('new')} className="w-full mb-6 bg-indigo-600 text-white px-4 py-2 rounded-md font-medium hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-colors duration-150" > + Create New Poll </button>
                                        <h3 className="text-lg font-medium text-gray-700 mb-3">Manage Polls</h3>
                                        {polls.length === 0 ? ( <p className="text-center text-gray-500 py-4">No polls created yet.</p> ) : (
                                            <div className="space-y-3">
                                                {polls.map(poll => (
                                                    <div key={poll.id} className="poll-list-item">
                                                        <div className="flex-1 min-w-0 pr-4">
                                                            <p className="text-gray-800 font-medium truncate" title={poll.question}>{poll.question}</p>
                                                            <span className={classNames( 
                                                                'status-badge', 
                                                                poll.poll_status === 'idle' && 'status-idle', 
                                                                poll.poll_status === 'active' && 'status-active', 
                                                                poll.poll_status === 'ended' && 'status-ended'
                                                            )}>
                                                                {poll.poll_status || 'idle'}
                                                            </span>
                                                            {/* Optionally show results summary for speaker */}
                                                            {poll.poll_status !== 'idle' && <p className="text-xs text-gray-500 mt-1">{poll.total_votes || 0} vote(s)</p>}
                                                        </div>
                                                        <div className="flex gap-2 flex-shrink-0">
                                                            <button 
                                                                onClick={() => handleEditPoll(poll)} 
                                                                disabled={poll.poll_status === 'active'} 
                                                                className="text-sm bg-white border border-gray-300 text-gray-700 px-3 py-1 rounded-md hover:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed"
                                                            >
                                                                Edit
                                                            </button>
                                                            <button 
                                                                onClick={() => handleTogglePollStatus(poll.id)} 
                                                                className={classNames(
                                                                    "text-sm text-white px-3 py-1 rounded-md transition-colors",
                                                                    poll.poll_status === 'active' ? 'bg-red-500 hover:bg-red-600' : 'bg-green-500 hover:bg-green-600',
                                                                    poll.poll_status === 'ended' && 'bg-gray-400 hover:bg-gray-500'
                                                                )}
                                                            >
                                                                {poll.poll_status === 'active' ? 'End Poll' : poll.poll_status === 'ended' ? 'Resume' : 'Start Poll'}
                                                            </button>
                                                            <button 
                                                                onClick={() => handleDeletePoll(poll.id)}
                                                                className="text-sm bg-red-100 text-red-700 px-3 py-1 rounded-md hover:bg-red-200 transition-colors"
                                                            >
                                                                Delete
                                                            </button>
                                                        </div>
                                                    </div>
                                                ))}
                                            </div>
                                        )}
                                    </div>
                                )}
                            </div>
                        ) : (
                            // --- Audience View (Shows only active and ended polls, one at a time) ---
                            visibleAudiencePolls.length === 0 ? (
                                <p className="text-center text-gray-500 py-8">No polls are currently available to view.</p>
                            ) : (
                                <div>
                                    {/* Audience Poll Navigation */}
                                    <div className="flex justify-between items-center mb-4">
                                        <button
                                            onClick={handleAudiencePrevPoll}
                                            disabled={currentAudiencePollIndex === 0}
                                            className="text-indigo-600 hover:text-indigo-800 disabled:opacity-50 disabled:cursor-not-allowed"
                                        >
                                            &larr; Previous
                                        </button>
                                        <span className="text-sm text-gray-500">
                                            Poll {currentAudiencePollIndex + 1} of {visibleAudiencePolls.length}
                                        </span>
                                        <button
                                            onClick={handleAudienceNextPoll}
                                            disabled={currentAudiencePollIndex === visibleAudiencePolls.length - 1}
                                            className="text-indigo-600 hover:text-indigo-800 disabled:opacity-50 disabled:cursor-not-allowed"
                                        >
                                            Next &rarr;
                                        </button>
                                    </div>

                                    {/* Display Current Audience Poll */}
                                    {currentAudiencePoll && (
                                        <>
                                            <h3 className="text-xl font-semibold text-gray-800 mb-5 text-center">{currentAudiencePoll.question}</h3>
                                            
                                            {/* Display poll image if exists */}
                                            {currentAudiencePoll.image_url && (
                                                <div className="mb-6 flex justify-center">
                                                    <img 
                                                        src={currentAudiencePoll.image_url} 
                                                        alt="Poll image" 
                                                        className="max-w-full h-auto rounded-lg shadow-md"
                                                        style={{ maxHeight: '300px' }}
                                                    />
                                                </div>
                                            )}
                                            
                                            {/* Handle different poll types */}
                                            {currentAudiencePoll.poll_type === 'open_ended' ? (
                                                // Open Answer Poll
                                                <div className="mb-6">
                                                    <textarea 
                                                        value={selectedOption || ''}
                                                        onChange={(e) => setSelectedOption(e.target.value)}
                                                        disabled={hasSubmittedCurrentPoll || currentAudiencePoll.poll_status !== 'active'}
                                                        placeholder="Type your answer here..."
                                                        className="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-1 focus:ring-indigo-500 focus:border-indigo-500 disabled:bg-gray-100 disabled:text-gray-500"
                                                        rows={4}
                                                    />
                                                    
                                                    {/* Submit Button for Open Answer */}
                                                    {currentAudiencePoll.poll_status === 'active' && !hasSubmittedCurrentPoll && (
                                                        <button
                                                            onClick={() => handleSubmitOpenAnswer(currentAudiencePoll.id, selectedOption)}
                                                            disabled={!selectedOption}
                                                            className="w-full mt-4 bg-green-600 text-white px-4 py-2 rounded-md font-medium hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-colors duration-150 disabled:opacity-50 disabled:cursor-not-allowed"
                                                        >
                                                            Submit Answer
                                                        </button>
                                                    )}
                                                </div>
                                            ) : (
                                                // Multiple/Single Choice Poll
                                                <div className="space-y-3 mb-6">
                                                    {currentAudiencePoll.options.map((option, index) => (
                                                        <div
                                                            key={index}
                                                            onClick={() => handleSelectOption(option)}
                                                            className={classNames(
                                                                'poll-option',
                                                                selectedOption === option && !hasSubmittedCurrentPoll && currentAudiencePoll.poll_status === 'active' && 'selected',
                                                                // Disable interaction visually if submitted or not active
                                                                (hasSubmittedCurrentPoll || currentAudiencePoll.poll_status !== 'active') && 'disabled submitted'
                                                            )}
                                                        >
                                                            {option}
                                                        </div>
                                                    ))}
                                                    
                                                    {/* Submit Button for Multiple/Single Choice */}
                                                    {currentAudiencePoll.poll_status === 'active' && !hasSubmittedCurrentPoll && (
                                                        <button
                                                            onClick={() => handleSubmitVote(currentAudiencePoll.id)}
                                                            disabled={!selectedOption}
                                                            className="w-full mt-4 bg-green-600 text-white px-4 py-2 rounded-md font-medium hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-colors duration-150 disabled:opacity-50 disabled:cursor-not-allowed"
                                                        >
                                                            Submit Answer
                                                        </button>
                                                    )}
                                                </div>
                                            )}
                                            
                                            {/* Submitted Message */}
                                            {hasSubmittedCurrentPoll && (
                                                <p className="text-center text-green-700 font-medium bg-green-100 p-3 rounded-md">Your answer for this poll has been submitted!</p>
                                            )}
                                            
                                            {/* Ended Message (if not submitted) */}
                                            {currentAudiencePoll.poll_status === 'ended' && !hasSubmittedCurrentPoll && (
                                                <p className="text-center text-red-700 font-medium bg-red-100 p-3 rounded-md">This poll has ended.</p>
                                            )}

                                            {/* Results (Show only if poll status is 'ended') */}
                                            {currentAudiencePoll.poll_status === 'ended' && (
                                                <div className="mt-6 border-t pt-4 border-gray-200">
                                                    <h4 className="text-lg font-medium text-gray-800 mb-3">Poll Results</h4>
                                                    {currentAudiencePoll.poll_type === 'open_ended' ? (
                                                        // Open Answer Results
                                                        <div className="space-y-2">
                                                            <p className="text-center text-gray-500">
                                                                Open answer responses:
                                                            </p>
                                                            {/* Display open answers from results */}
                                                            {pollResults[currentAudiencePoll.id]?.results?.length > 0 ? (
                                                                <div className="space-y-2">
                                                                    {pollResults[currentAudiencePoll.id].results.map((answer, index) => (
                                                                        <div key={index} className="bg-gray-50 p-3 rounded-md">
                                                                            <p className="text-gray-800">{answer.answer_text}</p>
                                                                            <p className="text-xs text-gray-500 mt-1">User ID: {answer.user_id}</p>
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                            ) : (
                                                                <div className="bg-gray-50 p-4 rounded-lg">
                                                                    <p className="text-sm italic text-gray-500">
                                                                        No responses have been submitted yet.
                                                                    </p>
                                                                </div>
                                                            )}
                                                        </div>
                                                    ) : (
                                                        // Multiple/Single Choice Results
                                                        <div className="space-y-3">
                                                            {currentAudiencePoll.options.map((option, index) => {
                                                                // Calculate votes from the results data
                                                                const votes = pollResults[currentAudiencePoll.id]?.results || [];
                                                                const voteCount = votes.filter(vote => 
                                                                    parseInt(vote.selected_option_index) === index
                                                                ).length;
                                                                
                                                                const totalVotes = votes.length;
                                                                const percentage = totalVotes > 0 ? ((voteCount / totalVotes) * 100).toFixed(1) : 0;
                                                                
                                                                return (
                                                                    <div key={index} className="w-full">
                                                                        <div className="flex justify-between items-center mb-1">
                                                                            <span className="text-sm font-medium text-gray-700">{option}</span>
                                                                            <span className="text-sm text-gray-500">{voteCount} vote(s)</span>
                                                                        </div>
                                                                        <div className="result-bar-bg">
                                                                            <div className="result-bar" style={{ width: `${percentage}%` }}>
                                                                                <span className="result-percentage">{percentage}%</span>
                                                                            </div>
                                                                            <span className="result-label">{option}</span>
                                                                        </div>
                                                                    </div>
                                                                );
                                                            })}
                                                            <p className="text-sm text-center text-gray-500 mt-2">
                                                                Total votes: {pollResults[currentAudiencePoll.id]?.results?.length || 0}
                                                            </p>
                                                        </div>
                                                    )}
                                                </div>
                                            )}
                                        </>
                                    )}
                                </div>
                            )
                        )
                      )}
                  </div>
              </div>
          );
      }
      // ## End Poll Tool Components ##
        
      // --- ToolList and App components remain the same ---
      function ToolList({ onSelectTool }) { /* ... ToolList component code ... */
         const tools = [ { id: 'raise-hand', name: 'Raise Hand (Q&A)', description: 'Ask questions, vote, and get answers.' }, { id: 'poll', name: 'Poll', description: 'Create and participate in live polls. (Coming Soon)' }, { id: 'find-teammate', name: 'Find Teammate', description: 'Connect with peers for group projects. (Coming Soon)' }, ];
         return ( <div className="min-h-screen bg-gradient-to-br from-indigo-100 via-purple-50 to-pink-100 flex items-center justify-center p-6 font-sans"> <div className="w-full max-w-2xl bg-white rounded-xl shadow-lg p-8"> <h1 className="text-3xl font-bold text-center text-gray-800 mb-8">Professor & Student Tools</h1> <div className="space-y-4"> {tools.map(tool => ( <button key={tool.id} onClick={() => onSelectTool(tool.id)} className="w-full text-left p-5 border border-gray-200 rounded-lg hover:bg-gray-100 hover:shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50 transition duration-150 ease-in-out" > <h2 className="text-xl font-semibold text-indigo-700">{tool.name}</h2> <p className="text-gray-600 mt-1">{tool.description}</p> </button> ))} </div> </div> </div> );
      }
      function App() { /* ... App component code remains the same ... */
        const [currentTool, setCurrentTool] = useState(null);
        const handleSelectTool = (toolId) => { if (toolId === 'raise-hand' || toolId === 'poll') { setCurrentTool(toolId); } else { alert(`Tool "${toolId}" is not yet implemented.`); } };
        const handleGoBack = () => { setCurrentTool(null); };
        if (currentTool === 'raise-hand') { return <RaiseHandTool onGoBack={handleGoBack} />; }
        if (currentTool === 'poll') { return <PollTool onGoBack={handleGoBack} />; }
        return <ToolList onSelectTool={handleSelectTool} />;
      }

      // --- Render the App ---
      const container = document.getElementById('root');
      const root = ReactDOM.createRoot(container);
      root.render(<App />);

    </script>
</body>
</html>
