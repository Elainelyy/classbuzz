<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professor/Student Tools</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
     <style>
        body { margin: 0; font-family: 'Inter', sans-serif; background-color: #f9fafb; }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        .dot { box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        /* Basic loading/error message styling */
        .message-box {
            text-align: center;
            padding: 20px;
            margin-top: 20px;
            border-radius: 8px;
        }
        .loading { background-color: #e0f2fe; color: #0c4a6e; }
        .error { background-color: #fee2e2; color: #991b1b; }
        .error-inline { color: #991b1b; font-size: 0.875rem; margin-top: 0.5rem; }
        /* Poll specific styles */
        .poll-option { cursor: pointer; border: 1px solid #e5e7eb; padding: 0.75rem 1rem; border-radius: 0.375rem; transition: background-color 0.15s ease-in-out, border-color 0.15s ease-in-out; }
        .poll-option:hover { background-color: #f9fafb; }
        .poll-option.selected { background-color: #e0e7ff; border-color: #a5b4fc; }
        .poll-option.submitted { cursor: default; }
         /* Simple bar chart for results */
        .result-bar-bg { background-color: #e5e7eb; height: 1.5rem; border-radius: 0.375rem; overflow: hidden; position: relative; }
        .result-bar { background-color: #6366f1; height: 100%; transition: width 0.3s ease-out; display: flex; align-items: center; justify-content: flex-end; padding-right: 0.5rem; color: white; font-size: 0.75rem; }
        .result-label { position: absolute; left: 0.5rem; top: 50%; transform: translateY(-50%); font-size: 0.875rem; color: #4b5563; }
        .result-percentage { font-weight: 500; }
     </style>
</head>
<body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <script type="text/babel">
      const { useState, useEffect, useMemo, useCallback } = React;

      // Base URL for API
      const API_BASE_URL = '';

      // --- Utility Functions ---
      function classNames(...classes) { return classes.filter(Boolean).join(' '); }

      // --- Mock Data ---
      const initialPollsData = [
          { id: 'p1', question: 'What is your favorite programming language?', options: ['JavaScript', 'Python', 'Java', 'C++'], results: { 'JavaScript': 15, 'Python': 25, 'Java': 8, 'C++': 5 }, userAnswers: {}, totalVotes: 53 }, // Store user answers keyed by a user ID (simulated)
          { id: 'p2', question: 'Which topic should we cover next week?', options: ['Async/Await', 'Database Indexing', 'WebSockets'], results: { 'Async/Await': 12, 'Database Indexing': 18, 'WebSockets': 9 }, userAnswers: {}, totalVotes: 39 },
      ];
      // --- Components ---
      function Comment({ comment }) {
        // Display relative time for comments (optional enhancement)
        // const timeAgo = /* Function to calculate time ago from comment.created_at */;
        return (
          <div className="ml-4 mt-2 p-2 bg-gray-100 rounded text-sm text-gray-700">
            <p>{comment.text}</p>
            {/* Optional: <span className="text-xs text-gray-500">{timeAgo}</span> */}
          </div>
        );
      }

      function Question({ question, onVote, onAddComment, onToggleAnswer, isSpeaker }) {
        const [showComments, setShowComments] = useState(false);
        const [newComment, setNewComment] = useState('');
        const [commentError, setCommentError] = useState(null); // State for comment errors

        // Use the actual comments array fetched from the backend
        const comments = question.comments || [];

        const handleAddCommentSubmit = async (e) => {
          e.preventDefault();
          const trimmedComment = newComment.trim();
          if (!trimmedComment) return;

          setCommentError(null); // Clear previous errors
          try {
            // Call the async function passed down from RaiseHandTool
            await onAddComment(question.id, trimmedComment);
            setNewComment(''); // Clear input on success
            setShowComments(true); // Keep comments open
          } catch (error) {
            console.error("Failed to add comment:", error);
            setCommentError(error.message || "Failed to post comment. Please try again.");
          }
        };


        return (
          <div className={classNames( "border rounded-lg p-4 mb-4 shadow-sm transition-colors duration-200", question.is_answered ? 'bg-green-50 border-green-200' : 'bg-white border-gray-200 hover:bg-gray-50' )}>
            <div className="flex items-start justify-between gap-4">
              <div className="flex-grow min-w-0">
                <p className={classNames( "text-gray-800 break-words", question.is_answered ? 'line-through text-gray-500' : '' )}>
                  {question.text}
                </p>
                <div className="text-sm text-gray-500 mt-2 flex flex-wrap items-center gap-x-4 gap-y-1">
                  {/* Vote Button */}
                  <button onClick={() => onVote(question.id)} disabled={question.is_answered} className={classNames( "flex items-center px-2 py-1 rounded transition-colors duration-150", question.is_answered ? "text-gray-400 cursor-not-allowed" : "text-blue-600 hover:bg-blue-100 disabled:opacity-50" )} aria-label={`Vote for question: ${question.text}`} >
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V7z" clipRule="evenodd" /></svg>
                    <span>{question.votes} Vote{question.votes !== 1 ? 's' : ''}</span>
                  </button>
                  {/* Comment Toggle Button */}
                  <button onClick={() => setShowComments(!showComments)} className="flex items-center text-gray-600 hover:text-indigo-600 text-sm" aria-expanded={showComments} aria-controls={`comments-${question.id}`} >
                     <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" /></svg>
                     {comments.length} Comment{comments.length !== 1 ? 's' : ''}
                  </button>
                   {/* Answered Status Badge */}
                   {question.is_answered && (
                      <span className="text-green-600 font-medium text-xs inline-flex items-center bg-green-100 px-2 py-0.5 rounded-full">
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-3 w-3 mr-1" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" /></svg>
                        Answered
                      </span>
                    )}
                </div>
              </div>
              {/* Speaker Action Button */}
              {isSpeaker && ( <button onClick={() => onToggleAnswer(question.id, !question.is_answered)} className={classNames( "flex-shrink-0 text-sm font-medium px-3 py-1 rounded transition-colors duration-150 self-start", question.is_answered ? 'bg-yellow-100 text-yellow-700 hover:bg-yellow-200' : 'bg-green-100 text-green-700 hover:bg-green-200' )} > {question.is_answered ? 'Mark Unanswered' : 'Mark Answered'} </button> )}
            </div>

            {/* Comments Section */}
            {showComments && (
              <div id={`comments-${question.id}`} className="mt-3 pl-4 border-l-2 border-gray-200">
                {comments.length > 0 ? (
                  comments.map(comment => <Comment key={comment.id} comment={comment} />)
                ) : ( <p className="text-sm text-gray-500 italic">No comments yet.</p> )}
                <form onSubmit={handleAddCommentSubmit} className="mt-3 flex items-center">
                  <input type="text" value={newComment} onChange={(e) => setNewComment(e.target.value)} placeholder="Add a comment..." className="flex-grow border border-gray-300 rounded-l px-3 py-1.5 text-sm focus:outline-none focus:ring-1 focus:ring-indigo-500 focus:border-indigo-500" aria-label="Add a comment to this question" />
                  <button type="submit" className="bg-indigo-600 text-white px-3 py-1.5 rounded-r text-sm font-medium hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-indigo-500 transition-colors duration-150 disabled:opacity-50" disabled={!newComment.trim()} > Add </button>
                </form>
                {commentError && <p className="error-inline">{commentError}</p>}
              </div>
            )}
          </div>
        );
      }

      /**
       * The main view for the "Raise Hand" tool.
       */
      function RaiseHandTool({ onGoBack }) {
        const [questions, setQuestions] = useState([]);
        const [isLoading, setIsLoading] = useState(true);
        const [error, setError] = useState(null);
        const [newQuestion, setNewQuestion] = useState('');
        const [isSpeaker, setIsSpeaker] = useState(false);

        // --- Fetch Questions (includes comments now - requires backend update) ---
        const fetchQuestions = useCallback(async () => {
          setIsLoading(true);
          setError(null);
          try {
            const response = await fetch(`${API_BASE_URL}/api/questions`); // Assume this now returns comments too
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            const questionsWithDates = data.map(q => ({
                ...q,
                createdAt: new Date(q.created_at),
                // Ensure comments have dates parsed if needed
                comments: (q.comments || []).map(c => ({ ...c, createdAt: new Date(c.created_at) }))
            }));
            setQuestions(questionsWithDates);
          } catch (e) {
            console.error("Failed to fetch questions:", e);
            setError("Failed to load questions. Please try again later.");
          } finally {
            setIsLoading(false);
          }
        }, []);

        useEffect(() => {
          fetchQuestions();
        }, [fetchQuestions]);

        // --- Add Question ---
        const handleAddQuestion = async (e) => {
          e.preventDefault();
          const trimmedQuestion = newQuestion.trim();
          if (!trimmedQuestion) return;
          const originalQuestions = questions; // Store state for potential revert
          setNewQuestion(''); // Clear input immediately

          // Optimistic update (optional)
          // const tempId = `temp-${Date.now()}`;
          // setQuestions(prev => [{ id: tempId, text: trimmedQuestion, votes: 0, is_answered: false, createdAt: new Date(), comments: [] }, ...prev]);

          try {
            const response = await fetch(`${API_BASE_URL}/api/questions`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ text: trimmedQuestion }),
            });
            if (!response.ok) {
              const errorData = await response.json();
              throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
            }
            const addedQuestion = await response.json();
            // Replace optimistic update or just add if not doing optimistic
            // Ensure comments array exists and dates are parsed
            const newQ = {
                ...addedQuestion,
                createdAt: new Date(addedQuestion.created_at),
                comments: (addedQuestion.comments || []).map(c => ({ ...c, createdAt: new Date(c.created_at) }))
            };
            // Add to the top of the list
             setQuestions(prevQuestions => [newQ, ...prevQuestions]);
             // If using optimistic: setQuestions(prev => prev.map(q => q.id === tempId ? newQ : q));

          } catch (e) {
            console.error("Failed to add question:", e);
            setError(`Failed to add question: ${e.message}. Please try again.`);
            setNewQuestion(trimmedQuestion); // Restore input on error
            // Revert optimistic update if used
            // setQuestions(originalQuestions);
          }
        };

        // --- Vote ---
        const handleVote = useCallback(async (questionId) => {
          // Optimistic update
          const originalQuestions = questions;
          setQuestions(prevQuestions =>
            prevQuestions.map(q =>
              q.id === questionId ? { ...q, votes: q.votes + 1 } : q
            )
          );

          try {
            const response = await fetch(`${API_BASE_URL}/api/questions/${questionId}/vote`, { method: 'POST' }); // Assuming POST endpoint
            if (!response.ok) {
                // Revert optimistic update on failure
                setQuestions(originalQuestions);
                const errorData = await response.json().catch(() => ({})); // Try to get error message
                throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
            }
            // Optional: Refetch or update state with response data if needed,
            // but optimistic update might be sufficient if backend just confirms success.
          } catch (e) {
            console.error("Failed to vote:", e);
            setError(`Vote failed: ${e.message}`);
            // Ensure state is reverted if fetch failed before parsing response
            setQuestions(originalQuestions);
          }
        }, [questions]); // Include questions to get latest state for revert

        // --- Add Comment ---
        const handleAddComment = useCallback(async (questionId, commentText) => {
          // Note: Optimistic update is handled partially in the Question component for temp display.
          // This function focuses on the API call. We expect it to throw on error.
          const response = await fetch(`${API_BASE_URL}/api/questions/${questionId}/comments`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ text: commentText }),
          });

          if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
          }

          const newComment = await response.json();

          // Update the specific question's comments array with the real comment from the backend
          setQuestions(prevQuestions =>
            prevQuestions.map(q =>
              q.id === questionId
                ? {
                    ...q,
                    comments: [
                        ...(q.comments || []), // Ensure comments array exists
                        { ...newComment, createdAt: new Date(newComment.created_at) } // Add the new comment with parsed date
                    ].sort((a, b) => new Date(a.created_at) - new Date(b.created_at)) // Keep comments sorted
                  }
                : q
            )
          );
          // Let the Question component handle clearing input etc. via try/catch around this call
        }, []); // No dependency on questions state needed here directly

        // --- Toggle Answer ---
        const handleToggleAnswer = useCallback(async (questionId, newAnsweredState) => {
          if (!isSpeaker) return;
          const originalQuestions = questions;

          // Optimistic update
          setQuestions(prevQuestions =>
            prevQuestions.map(q =>
              q.id === questionId ? { ...q, is_answered: newAnsweredState } : q
            )
          );

          try {
            const response = await fetch(`${API_BASE_URL}/api/questions/${questionId}/answer`, { // Assuming PATCH endpoint
              method: 'PATCH',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ is_answered: newAnsweredState }),
            });
             if (!response.ok) {
                setQuestions(originalQuestions); // Revert
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
            }
            // Optional: update state with response data if backend modifies it further
          } catch (e) {
            console.error("Failed to toggle answer status:", e);
            setError(`Update failed: ${e.message}`);
            setQuestions(originalQuestions); // Revert
          }
        }, [isSpeaker, questions]); // Include questions for revert, isSpeaker for check


        // --- Sorting Logic (remains the same) ---
        const sortedQuestions = useMemo(() => {
          return [...questions].sort((a, b) => {
            if (a.is_answered !== b.is_answered) { return a.is_answered ? 1 : -1; }
            if (b.votes !== a.votes) { return b.votes - a.votes; }
            const dateA = a.createdAt instanceof Date ? a.createdAt.getTime() : 0;
            const dateB = b.createdAt instanceof Date ? b.createdAt.getTime() : 0;
            return dateA - dateB;
          });
        }, [questions]);

        // --- Render UI ---
        return (
          <div className="p-4 sm:p-6 bg-gray-50 min-h-screen font-sans relative">
             <button onClick={onGoBack} className="absolute top-4 left-4 z-10 bg-white text-indigo-600 px-3 py-1 rounded-md shadow text-sm font-medium hover:bg-indigo-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" aria-label="Go back to tool list" > &larr; Back to Tools </button>
             <div className="max-w-3xl mx-auto bg-white p-6 rounded-lg shadow-md mt-12 sm:mt-16">
                {/* Header and Speaker Toggle */}
                <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-6 pb-4 border-b border-gray-200 gap-4">
                  <h2 className="text-2xl font-semibold text-gray-800 flex-shrink-0">Raise Hand / Q&A</h2>
                  <label className="flex items-center cursor-pointer flex-shrink-0">
                    <span className="mr-2 text-sm font-medium text-gray-700">Speaker Mode:</span>
                    <div className="relative">
                      <input type="checkbox" className="sr-only peer" checked={isSpeaker} onChange={() => setIsSpeaker(!isSpeaker)} id="speaker-toggle" />
                      <div className="w-10 h-6 rounded-full transition bg-gray-300 peer-checked:bg-indigo-600"></div>
                      <div className="absolute left-1 top-1 bg-white w-4 h-4 rounded-full transition transform peer-checked:translate-x-4 dot"></div>
                    </div>
                  </label>
                </div>
                {/* Add Question Form */}
                <form onSubmit={handleAddQuestion} className="mb-6 flex flex-col sm:flex-row gap-2">
                  <input type="text" value={newQuestion} onChange={(e) => setNewQuestion(e.target.value)} placeholder="Ask a question..." className="flex-grow border border-gray-300 rounded-md px-4 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500" aria-label="Ask a new question" />
                  <button type="submit" className="bg-indigo-600 text-white px-4 py-2 rounded-md font-medium hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-colors duration-150 disabled:opacity-50" disabled={!newQuestion.trim()} > Ask </button>
                </form>
                 {/* Display Top-Level Error */}
                 {error && <div className="message-box error mb-4">{error}</div>}

                {/* Display Loading / Questions List */}
                <div className="space-y-4">
                   <h3 className="text-lg font-medium text-gray-700 mb-2">Questions</h3>
                   {isLoading && <div className="message-box loading">Loading questions...</div>}
                   {!isLoading && !error && sortedQuestions.length === 0 && (
                       <p className="text-gray-500 italic text-center py-4">No questions asked yet. Be the first!</p>
                   )}
                   {!isLoading && !error && sortedQuestions.length > 0 && (
                      sortedQuestions.map(question => (
                        <Question
                          key={question.id}
                          question={question}
                          onVote={handleVote} // Pass down the updated handlers
                          onAddComment={handleAddComment}
                          onToggleAnswer={handleToggleAnswer}
                          isSpeaker={isSpeaker}
                        />
                      ))
                   )}
                </div>
             </div>
          </div>
        );
      }

      // ## Poll Tool Components ##

      function PollResults({ results, totalVotes, options }) { /* ... PollResults component code ... */
         if (totalVotes === 0) { return <p className="text-sm text-gray-500 italic mt-4">No votes yet.</p>; }
         return ( <div className="mt-6 space-y-3"> <h4 className="font-medium text-gray-700">Results ({totalVotes} total votes):</h4> {options.map(option => { const count = results[option] || 0; const percentage = totalVotes > 0 ? ((count / totalVotes) * 100).toFixed(1) : 0; return ( <div key={option} className="result-bar-bg"> <span className="result-label">{option}</span> <div className="result-bar" style={{ width: `${percentage}%` }}> <span className="result-percentage">{percentage}%</span>&nbsp;({count}) </div> </div> ); })} </div> );
      }

      function PollEditor({ onCreatePoll }) { /* ... PollEditor component code ... */
        const [question, setQuestion] = useState(''); const [options, setOptions] = useState(['', '']);
        const handleOptionChange = (index, value) => { const newOptions = [...options]; newOptions[index] = value; setOptions(newOptions); };
        const handleAddOption = () => { if (options.length < 10) { setOptions([...options, '']); } };
        const handleRemoveOption = (index) => { if (options.length > 2) { const newOptions = options.filter((_, i) => i !== index); setOptions(newOptions); } };
        const handleSubmit = (e) => { e.preventDefault(); const validOptions = options.map(o => o.trim()).filter(o => o !== ''); if (question.trim() && validOptions.length >= 2) { onCreatePoll({ question: question.trim(), options: validOptions }); setQuestion(''); setOptions(['', '']); } else { alert("Please provide a question and at least two non-empty answer options."); } };
        return ( <form onSubmit={handleSubmit} className="space-y-4 p-4 border border-dashed border-gray-300 rounded-lg bg-gray-50"> <h3 className="text-lg font-medium text-gray-800">Create New Poll</h3> <div> <label htmlFor="poll-question" className="block text-sm font-medium text-gray-700 mb-1">Question:</label> <input type="text" id="poll-question" value={question} onChange={(e) => setQuestion(e.target.value)} placeholder="Enter poll question..." required className="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-1 focus:ring-indigo-500 focus:border-indigo-500" /> </div> <div> <label className="block text-sm font-medium text-gray-700 mb-1">Answer Options:</label> {options.map((option, index) => ( <div key={index} className="flex items-center gap-2 mb-2"> <input type="text" value={option} onChange={(e) => handleOptionChange(index, e.target.value)} placeholder={`Option ${index + 1}`} required className="flex-grow border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-1 focus:ring-indigo-500 focus:border-indigo-500" /> {options.length > 2 && ( <button type="button" onClick={() => handleRemoveOption(index)} className="text-red-600 hover:text-red-800 p-1" aria-label="Remove option" > <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"> <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM7 9a1 1 0 000 2h6a1 1 0 100-2H7z" clipRule="evenodd" /> </svg> </button> )} </div> ))} {options.length < 10 && ( <button type="button" onClick={handleAddOption} className="text-sm text-indigo-600 hover:text-indigo-800 mt-1" > + Add Option </button> )} </div> <button type="submit" className="w-full bg-indigo-600 text-white px-4 py-2 rounded-md font-medium hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-colors duration-150" > Create Poll </button> </form> );
      }

      function PollTool({ onGoBack }) {
          const [polls, setPolls] = useState(initialPollsData);
          const [currentPollIndex, setCurrentPollIndex] = useState(0);
          const [selectedOption, setSelectedOption] = useState(null);
          const [isSpeaker, setIsSpeaker] = useState(false);
          const [speakerMode, setSpeakerMode] = useState('viewer');
          const [submittedAnswers, setSubmittedAnswers] = useState({});

          const currentPoll = polls[currentPollIndex];
          const hasSubmitted = submittedAnswers[currentPoll?.id];

          const handleSelectOption = (option) => { if (hasSubmitted || isSpeaker) return; setSelectedOption(option); };

          const handleSubmitAnswer = () => {
              if (!selectedOption || hasSubmitted || isSpeaker) return;
              const pollId = currentPoll.id;
              // --- Simulate Submission & Result Update ---
              const updatedPolls = polls.map(poll => { if (poll.id === pollId) { const newResults = { ...poll.results }; newResults[selectedOption] = (newResults[selectedOption] || 0) + 1; const newTotalVotes = poll.totalVotes + 1; const newUserAnswers = { ...poll.userAnswers, 'user1': selectedOption }; return { ...poll, results: newResults, totalVotes: newTotalVotes, userAnswers: newUserAnswers }; } return poll; });
              setPolls(updatedPolls);
              setSubmittedAnswers(prev => ({ ...prev, [pollId]: true }));
              // TODO: Replace simulation with API call
          };

          const handleCreatePoll = (newPollData) => {
             const newPoll = { id: `p${Date.now()}`, question: newPollData.question, options: newPollData.options, results: newPollData.options.reduce((acc, option) => { acc[option] = 0; return acc; }, {}), userAnswers: {}, totalVotes: 0 };

             // --- FIX START ---
             // Use the updater function for setPolls
             // Calculate the new index based on the *previous* length
             // and set the index *before* returning the new state array
             setPolls(prevPolls => {
                 const newIndex = prevPolls.length; // Index where the new poll will be
                 setCurrentPollIndex(newIndex); // Set index to navigate to the new poll
                 return [...prevPolls, newPoll]; // Return the updated array
             });
             // --- FIX END ---

             setSpeakerMode('viewer'); // Switch mode after scheduling state updates
             // TODO: Replace simulation with API call: POST /api/polls
          };

          const handleNextPoll = () => { if (currentPollIndex < polls.length - 1) { setCurrentPollIndex(currentPollIndex + 1); } };
          const handlePrevPoll = () => { if (currentPollIndex > 0) { setCurrentPollIndex(currentPollIndex - 1); } };

          useEffect(() => {
              setSelectedOption(null);
              const pollId = polls[currentPollIndex]?.id;
              if (pollId && submittedAnswers[pollId]) {
                  const userAnswer = polls[currentPollIndex]?.userAnswers?.['user1'];
                  if(userAnswer) setSelectedOption(userAnswer);
              }
          }, [currentPollIndex, polls, submittedAnswers]);

          return (
              <div className="p-4 sm:p-6 bg-gray-50 min-h-screen font-sans relative">
                  <button onClick={onGoBack} className="absolute top-4 left-4 z-10 bg-white text-indigo-600 px-3 py-1 rounded-md shadow text-sm font-medium hover:bg-indigo-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500" aria-label="Go back to tool list"> &larr; Back to Tools </button>
                  <div className="max-w-3xl mx-auto bg-white p-6 rounded-lg shadow-md mt-12 sm:mt-16">
                      {/* Header & Mode Toggles */}
                      <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-6 pb-4 border-b border-gray-200 gap-4">
                           <h2 className="text-2xl font-semibold text-gray-800 flex-shrink-0">Poll</h2>
                           <div className="flex items-center gap-4">
                               <label className="flex items-center cursor-pointer flex-shrink-0"> <span className="mr-2 text-sm font-medium text-gray-700">Speaker:</span> <div className="relative"> <input type="checkbox" className="sr-only peer" checked={isSpeaker} onChange={() => setIsSpeaker(!isSpeaker)} id="poll-speaker-toggle" /> <div className="w-10 h-6 rounded-full transition bg-gray-300 peer-checked:bg-indigo-600"></div> <div className="absolute left-1 top-1 bg-white w-4 h-4 rounded-full transition transform peer-checked:translate-x-4 dot"></div> </div> </label>
                               {isSpeaker && ( <div className="flex items-center gap-2 p-1 bg-gray-100 rounded-lg"> <button onClick={() => setSpeakerMode('viewer')} className={classNames("px-3 py-1 rounded-md text-sm font-medium transition-colors", speakerMode === 'viewer' ? 'bg-white text-indigo-700 shadow-sm' : 'text-gray-600 hover:text-gray-800')} >Viewer</button> <button onClick={() => setSpeakerMode('editor')} className={classNames("px-3 py-1 rounded-md text-sm font-medium transition-colors", speakerMode === 'editor' ? 'bg-white text-indigo-700 shadow-sm' : 'text-gray-600 hover:text-gray-800')} >Editor</button> </div> )}
                           </div>
                       </div>
                      {/* Content Area */}
                      {isSpeaker && speakerMode === 'editor' ? ( <PollEditor onCreatePoll={handleCreatePoll} /> ) : ( !currentPoll ? ( <p className="text-center text-gray-500 py-8">No polls available.</p> ) : ( <div> <div className="flex justify-between items-center mb-4"> <button onClick={handlePrevPoll} disabled={currentPollIndex === 0} className="text-indigo-600 hover:text-indigo-800 disabled:opacity-50 disabled:cursor-not-allowed" > &larr; Previous </button> <span className="text-sm text-gray-500">Poll {currentPollIndex + 1} of {polls.length}</span> <button onClick={handleNextPoll} disabled={currentPollIndex === polls.length - 1} className="text-indigo-600 hover:text-indigo-800 disabled:opacity-50 disabled:cursor-not-allowed" > Next &rarr; </button> </div> <h3 className="text-xl font-semibold text-gray-800 mb-5 text-center">{currentPoll.question}</h3> <div className="space-y-3 mb-6"> {currentPoll.options.map(option => ( <div key={option} onClick={() => handleSelectOption(option)} className={classNames( 'poll-option', selectedOption === option && !hasSubmitted && 'selected', (hasSubmitted || isSpeaker) && 'submitted' )} > {option} </div> ))} </div> {!isSpeaker && !hasSubmitted && ( <button onClick={handleSubmitAnswer} disabled={!selectedOption} className="w-full bg-green-600 text-white px-4 py-2 rounded-md font-medium hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-colors duration-150 disabled:opacity-50 disabled:cursor-not-allowed" > Submit Answer </button> )} {!isSpeaker && hasSubmitted && ( <p className="text-center text-green-700 font-medium bg-green-100 p-3 rounded-md">Your answer has been submitted!</p> )} {(isSpeaker || hasSubmitted) && ( <PollResults results={currentPoll.results} totalVotes={currentPoll.totalVotes} options={currentPoll.options} /> )} </div> ) )}
                  </div>
              </div>
          );
      }
      // ## End Poll Tool Components ##
        
      // --- ToolList and App components remain the same ---
      function ToolList({ onSelectTool }) { /* ... ToolList component code ... */
         const tools = [ { id: 'raise-hand', name: 'Raise Hand (Q&A)', description: 'Ask questions, vote, and get answers.' }, { id: 'poll', name: 'Poll', description: 'Create and participate in live polls. (Coming Soon)' }, { id: 'find-teammate', name: 'Find Teammate', description: 'Connect with peers for group projects. (Coming Soon)' }, ];
         return ( <div className="min-h-screen bg-gradient-to-br from-indigo-100 via-purple-50 to-pink-100 flex items-center justify-center p-6 font-sans"> <div className="w-full max-w-2xl bg-white rounded-xl shadow-lg p-8"> <h1 className="text-3xl font-bold text-center text-gray-800 mb-8">Professor & Student Tools</h1> <div className="space-y-4"> {tools.map(tool => ( <button key={tool.id} onClick={() => onSelectTool(tool.id)} className="w-full text-left p-5 border border-gray-200 rounded-lg hover:bg-gray-100 hover:shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50 transition duration-150 ease-in-out" > <h2 className="text-xl font-semibold text-indigo-700">{tool.name}</h2> <p className="text-gray-600 mt-1">{tool.description}</p> </button> ))} </div> </div> </div> );
      }
      function App() { /* ... App component code remains the same ... */
        const [currentTool, setCurrentTool] = useState(null);
        const handleSelectTool = (toolId) => { if (toolId === 'raise-hand' || toolId === 'poll') { setCurrentTool(toolId); } else { alert(`Tool "${toolId}" is not yet implemented.`); } };
        const handleGoBack = () => { setCurrentTool(null); };
        if (currentTool === 'raise-hand') { return <RaiseHandTool onGoBack={handleGoBack} />; }
        if (currentTool === 'poll') { return <PollTool onGoBack={handleGoBack} />; }
        return <ToolList onSelectTool={handleSelectTool} />;
      }

      // --- Render the App ---
      const container = document.getElementById('root');
      const root = ReactDOM.createRoot(container);
      root.render(<App />);

    </script>
</body>
</html>
